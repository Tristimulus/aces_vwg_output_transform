#! /lucas/ilm/sww/rhel7/tools/bundles/versions/Nuke12.0v8#1.0/libnuke-12.0.8.so -nx
version 12.0 v8
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="0" w="2559" h="1378" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1896" stretch="1"/>
            <splitter orientation="2">
                <split size="782"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="550"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /dept/clrimg/matthias/ampas/output_vwg/nuke/DRT_ZCAM_IzMh_v08_Blink.nk
 frame 13
 last_frame 65
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 OCIO_config custom
 customOCIOConfigPath /Users/afry/Documents/GitHub/OpenColorIO-Configs/aces_1.2/config.ocio
 defaultViewerLUT "OCIO LUTs"
 workingSpaceLUT linear
 monitorLut sRGB
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
 addUserKnob {20 GMS l "Global MotionBlur Controls"}
 addUserKnob {20 TGC l "Transform Global Control" n 1}
 addUserKnob {7 motionblur l "motion blur" R 0 4}
 addUserKnob {7 shutter R 0 4}
 addUserKnob {1 t_ind l status:}
 addUserKnob {22 batchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.tc_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 batchoninteractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.tc_batch_on_interactive_off()"}
 addUserKnob {22 batchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.tc_batch_off_interactive_off()"}
 addUserKnob {7 msamplert +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {20 RRGC l "Roto Render Global Control" n 1}
 addUserKnob {6 motionBlur l "motion blur" t "Toggle motionBlurAllCrvs on/off" +STARTLINE}
 addUserKnob {6 motionBlurAllCrvs l "motion blur all crvs" t "Toggle motionBlurAllCrvs on/off" +STARTLINE}
 addUserKnob {7 shutterAngle l "shutter angle" R 0 360}
 addUserKnob {7 shutterStart l "shutter start" R -180 180}
 addUserKnob {7 motionBlurSteps l "motion blur steps" R 0 2}
 addUserKnob {1 rr_ind l status:}
 addUserKnob {22 rrbatchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rr_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 rrbatchointeractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rr_batch_on_interactive_off()"}
 addUserKnob {22 rrbatchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rr_batch_off_interactive_off()"}
 addUserKnob {20 endGroup_2 l endGroup n -1}
 addUserKnob {20 C3dGC l "Card3D Global Control" n 1}
 addUserKnob {7 motionblurc3d l "motion blur" R 0 4}
 addUserKnob {7 shutterc3d l shutter R 0 2}
 addUserKnob {1 c3d_ind l status:}
 addUserKnob {22 c3dbatchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.c3d_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 crdbatchoninteractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.c3d_batch_on_interactive_off()"}
 addUserKnob {22 c3dbatchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.c3d_batch_off_interactive_off()"}
 addUserKnob {7 msamplerc3d +HIDDEN}
 addUserKnob {20 endGroup_3 l endGroup n -1}
 addUserKnob {20 sr l "Scanline Render Global Control" n 1}
 addUserKnob {7 prescan_samples l samples R 0 50}
 addUserKnob {7 batch_samples l "batch samples" R 0 50}
 addUserKnob {7 scan_shutter l shutter}
 addUserKnob {1 sr_ind l status:}
 addUserKnob {22 srbatchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.sr_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 srbatchoninteractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.sr_batch_on_interactive_off()"}
 addUserKnob {22 srbatchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.sr_batch_off_interactive_off()"}
 addUserKnob {7 scan_sampler +HIDDEN R 0 50}
 addUserKnob {7 scan_samples +HIDDEN R 0 50}
 addUserKnob {7 batch_sampler +HIDDEN R 0 10}
 addUserKnob {20 endGroup_4 l endGroup n -1}
 addUserKnob {20 rn l "Roto Node Global Control" n 1}
 addUserKnob {6 rotoMotionBlur_on l "motion blur" t "toggle motionBlur button on Roto nodes on or off\n" +STARTLINE}
 addUserKnob {7 rotoMotionBlur_samples l "motion blur samples" t "Sets the number of motion blur samples" R 0 4}
 addUserKnob {7 rotoMotionBlur_shutter l "motion blur shutter" t "This sets how long the shutter should be open. The value is in frames, so 0.5 is half a frame" R 0 2}
 addUserKnob {4 rotoShutterOffsetType l "shutter offset type" t "The value of this controls how the shutter behaves with respect to the current frame value" M {centred start end custom}}
 addUserKnob {7 rotoShutterOffset l "shutter offset" t "If the 'shutter offset type' is set to 'custom', this parameter is used to set the time the shutter opens by adding it to the current frame. \nValues are in frames, so -0.5 would open the shutter half a frame before the current frame" R -1 1}
 addUserKnob {1 rn_ind l status:}
 addUserKnob {22 rnbatchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rn_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 rnbatchointeractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rn_batch_on_interactive_off()"}
 addUserKnob {22 rnbatchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rn_batch_off_interactive_off()"}
 addUserKnob {20 endGroup_5 l endGroup n -1}
}
BackdropNode {
 inputs 0
 name BackdropNode8
 tile_color 0x696969ff
 label "DRT_ ZCAM_IzMh_v08_Blink"
 note_font_size 20
 xpos -2295
 ypos -689
 bdwidth 573
 bdheight 316
}
BackdropNode {
 inputs 0
 name BackdropNode1
 label "SDR Settings"
 note_font_size 16
 xpos -2281
 ypos -642
 bdwidth 260
 bdheight 250
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode2
 label "HDR Settings"
 note_font_size 16
 xpos -2008
 ypos -643
 bdwidth 260
 bdheight 250
 z_order 1
}
Group {
 inputs 0
 name GeneratGridZCAM1
 note_font "Bitstream Vera Sans"
 xpos -2177
 ypos -593
 addUserKnob {20 User}
 addUserKnob {26 zcam_settings_divider l "ZCAM Settings"}
 addUserKnob {41 referenceWhite T ZCAM_JMh_Blink2.referenceWhite}
 addUserKnob {41 zcamReferenceLuminance l referenceLuminance -STARTLINE T ZCAM_JMh_Blink2.referenceLuminance}
 addUserKnob {41 viewingConditions T ZCAM_JMh_Blink2.viewingConditions}
 addUserKnob {41 backgroundLuminance -STARTLINE T ZCAM_JMh_Blink2.backgroundLuminance}
 addUserKnob {41 catType l "CAT Type" T ZCAM_JMh_Blink2.catType}
 addUserKnob {41 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE T ZCAM_JMh_Blink2.discountIlluminant}
 addUserKnob {26 grid_setting_divider l "Grid Settings"}
 addUserKnob {7 hueSlice l "hue slice" R 0 360}
 hueSlice {{Plot_ZCAM_JMh_Boundary1.hue}}
 addUserKnob {7 MRange l "M range" R 0 100}
 MRange 80
 addUserKnob {7 luminanceRange l "luminance range" R 0 1000}
 luminanceRange 1000
 addUserKnob {26 output_settings_divider l "Output Settings"}
 addUserKnob {41 colorspace_out l colorspace T Colorspace1.colorspace_out}
 addUserKnob {41 illuminant_out l "" -STARTLINE T Colorspace1.illuminant_out}
 addUserKnob {41 primary_out l "" -STARTLINE T Colorspace1.primary_out}
 addUserKnob {7 outputReferenceLuminance l referenceLuminance R 0 10000}
 outputReferenceLuminance 100
}
 Constant {
  inputs 0
  format "1024 1024 0 0 1024 1024 1 square_1k"
  name Constant6
  xpos -908
  ypos -278
 }
 Reformat {
  type "to box"
  box_width 512
  box_height 16
  box_fixed true
  resize none
  name Reformat1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -206
 }
set N1a7146a0 [stack 0]
 Reformat {
  type scale
  box_width 512
  box_height 16
  box_fixed true
  resize none
  turn true
  name Reformat6
  note_font "Bitstream Vera Sans"
  xpos -798
  ypos -206
 }
 Expression {
  temp_name0 vx
  temp_expr0 x/(input.width-1)
  temp_name1 vy
  temp_expr1 y/(input.height-1)
  expr0 vy
  expr1 vx
  expr2 1
  expr3 0
  name Expression7
  label "Generate Ramps"
  note_font "Bitstream Vera Sans"
  xpos -798
  ypos -182
 }
 Reformat {
  type scale
  box_width 512
  box_height 16
  box_fixed true
  resize none
  flip true
  flop true
  turn true
  black_outside true
  pbb true
  name Reformat7
  note_font "Bitstream Vera Sans"
  xpos -798
  ypos -146
 }
push $N1a7146a0
 Expression {
  temp_name0 vx
  temp_expr0 x/(input.width-1)
  temp_name1 vy
  temp_expr1 y/(input.height-1)
  expr0 vy
  expr1 vx
  expr2 1
  expr3 0
  name Expression8
  label "Generate Ramps"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -182
 }
 ContactSheet {
  inputs 2
  width {{input.width}}
  height {{input.height*2}}
  rows 2
  columns 1
  name ContactSheet6
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -146
 }
set N1a75ec60 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  alpha white
  name Shuffle1
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1093
  ypos -152
 }
 Multiply {
  channels rgb
  value {{parent.luminanceRange}}
  name Multiply1
  note_font "Bitstream Vera Sans"
  xpos -1093
  ypos -116
 }
 Group {
  name ZCAM_JMh_Blink1
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  selected true
  xpos -1093
  ypos -82
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.zcamReferenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1a79d710 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1a7a2630 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1a7a2630
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1a79d710
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Shuffle {
  green white
  blue white
  alpha white
  name Shuffle2
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1093
  ypos -37
 }
push $N1a75ec60
 Multiply {
  channels rgb
  value {1 {parent.MRange} {parent.hueSlice} 1}
  name Multiply7
  label "Scale M & h"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -93
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  label "scale J"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -37
 }
 Group {
  name ZCAM_JMh_Blink2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 20
  addUserKnob {20 User}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance 100
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance 10
  addUserKnob {4 catType l "CAT Type" M {None "XYZ Scaling" Bradford CAT02 Zhai2018}}
  catType Zhai2018
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1a858fe0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1a85df00 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1a85df00
  Colorspace {
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1a858fe0
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   selected true
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Multiply {
  value {{1/outputReferenceLuminance}}
  name Multiply8
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 57
  disable {{Colorspace1.colorspace_out==31}}
 }
 Colorspace {
  colorspace_in CIE-XYZ
  illuminant_out ACES
  primary_out ACES
  name Colorspace1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 121
 }
 Output {
  name Output1
  xpos -908
  ypos 221
 }
end_group
Group {
 name DRT_ZCAM_IzMh_v08_Blink1
 label "\[value ssts_luminance.2]nits/\[value gamut]\n\[value colorspace_out]/\[value illuminant_out]/\[value primary_out]\n\n"
 note_font "Bitstream Vera Sans"
 xpos -2177
 ypos -539
 addUserKnob {20 User}
 addUserKnob {26 div_input l Input}
 addUserKnob {41 colorspace_in l colorspace T Colorspace1.colorspace_in}
 addUserKnob {41 illuminant_in l "" -STARTLINE T Colorspace1.illuminant_in}
 addUserKnob {41 primary_in l "" -STARTLINE T Colorspace1.primary_in}
 addUserKnob {41 catType l "CAT Type" T ZCAM_JMh_Blink1.catType}
 addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
 addUserKnob {26 div_ssts l SSTS}
 addUserKnob {6 applySSTS l "apply SSTS" +STARTLINE}
 applySSTS true
 addUserKnob {78 ssts_luminance l luminance n 3}
 ssts_luminance {0.0001 10 100}
 addUserKnob {26 ssts_label l "" -STARTLINE T "  min / mid / peak"}
 addUserKnob {6 applyHighlightDesat l "apply highlight de-sat" +STARTLINE}
 applyHighlightDesat true
 addUserKnob {7 desatHighlights l "de-sat highlights" R 0 10}
 desatHighlights 3.5
 addUserKnob {26 div_gamutmap l "Gamut Mapping"}
 addUserKnob {41 white T ZCAM_GamutBoundaryBlink1.boundaryWhite}
 addUserKnob {41 gamut -STARTLINE T ZCAM_GamutBoundaryBlink1.boundaryGamut}
 addUserKnob {6 applyGamutMappingJ l "apply gamut mapping (J)" +STARTLINE}
 applyGamutMappingJ true
 addUserKnob {3 precisionJ l precision -STARTLINE}
 precisionJ 8
 addUserKnob {26 precision_J_label l "" -STARTLINE T "(for gamut cusp)"}
 addUserKnob {4 focusTarget M {"Gamut Cusp" "SSTS Mid"}}
 addUserKnob {7 focusScale -STARTLINE R 0 2}
 focusScale 1
 addUserKnob {78 compressionJ l "compression (J)" n 3}
 compressionJ {0.8 1.3 1.2}
 addUserKnob {26 compression_J_label l "" -STARTLINE T " threshold / limit / power"}
 addUserKnob {6 applyGamutMappingM l "apply gamut mapping (M)" +STARTLINE}
 applyGamutMappingM true
 addUserKnob {3 precisionM l precision -STARTLINE}
 precisionM 10
 addUserKnob {26 precision_label l "" -STARTLINE T " (for gamut boundary)"}
 addUserKnob {78 compressionM l "compression (M)" n 3}
 compressionM {0.8 1.3 1.2}
 addUserKnob {26 compression_label l "" -STARTLINE T " threshold / limit / power"}
 addUserKnob {26 div_output l Output}
 addUserKnob {41 colorspace_out l colorspace T Colorspace3.colorspace_out}
 addUserKnob {41 illuminant_out l "" -STARTLINE T Colorspace3.illuminant_out}
 addUserKnob {41 primary_out l "" -STARTLINE T Colorspace3.primary_out}
 addUserKnob {41 viewingConditions T ZCAM_JMh_Blink1.viewingConditions}
 addUserKnob {78 reference_luminance l "luminance reference" -STARTLINE n 1}
 reference_luminance 100
 addUserKnob {78 background_luminance l background -STARTLINE n 1}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" +STARTLINE}
 addUserKnob {26 direction}
 addUserKnob {6 invert +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  label "Un-Compress Lightness (J) from Target Gamut Cusp or SSTS mid-point\nApproximation only because original gamut boundary value has been obfuscated by the change in J\nUsing a multi-stage inverse improves precision but is expensive"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -516
  ypos -443
  bdwidth 1259
  bdheight 457
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  label "Convert J component to linearised Iz component\nand apply inverse ACES SSTS\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -517
  ypos 26
  bdwidth 1260
  bdheight 602
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  label "IzMh (ZCAM) to Output\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -518
  ypos 639
  bdwidth 1266
  bdheight 224
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  label "Compress Colourfulness (M)\nto Target Gamut Boundary\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1363
  ypos 319
  bdwidth 798
  bdheight 282
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  label "Very handwavy attempt at basing \na highlight de-sat on tonescale\n\n(this inverse node graph is more complex than than the forward graph\nin order to support separate disabling of the SSTS)"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos 760
  ypos 21
  bdwidth 873
  bdheight 616
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  label "Compress Lightness (J)\ntowards Target Gamut Cusp\nor SSTS mid-point"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1364
  ypos -75
  bdwidth 801
  bdheight 383
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  label "Apply ACES SSTS to linearised Iz component\nand convert to J component"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1366
  ypos -703
  bdwidth 802
  bdheight 620
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  label "Input to IzMh (ZCAM)\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1366
  ypos -983
  bdwidth 799
  bdheight 269
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  label "JMh (ZCAM) to Output\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1363
  ypos 610
  bdwidth 799
  bdheight 261
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  label "Very handwavy attempt at basing \na highlight de-sat on tonescale"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1876
  ypos -707
  bdwidth 498
  bdheight 1015
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  label "Input to JMh (ZCAM)\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -516
  ypos -985
  bdwidth 1251
  bdheight 267
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  label "Un-Compress Colourfulness (M) from Target Gamut\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -512
  ypos -704
  bdwidth 1253
  bdheight 243
 }
 Input {
  inputs 0
  name Input
  xpos -516
  ypos -1216
 }
 Dot {
  name Dot15
  note_font "Bitstream Vera Sans"
  xpos -482
  ypos -1035
 }
set N1a953ba0 [stack 0]
 Dot {
  name Dot17
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos -1035
 }
 Colorspace {
  colorspace_in {{Colorspace3.colorspace_out}}
  illuminant_in {{Colorspace3.illuminant_out}}
  primary_in {{Colorspace3.primary_out}}
  colorspace_out CIE-XYZ
  name Colorspace2
  label "XYZ to Output\ninverse"
  xpos 450
  ypos -896
 }
 Multiply {
  channels rgb
  value {{parent.ssts_luminance.2}}
  name Multiply13
  label "Lum to Linear\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos -854
  disable {{Colorspace2.colorspace_in==31}}
 }
 Group {
  name ZCAM_JMh_Blink3
  label "XYZ to JMh\nno drop-downs"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos -799
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.white}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1a9987a0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1a99d6f0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1a99d6f0
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1a9987a0
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Dot {
  name Dot19
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos -670
 }
set N1aa10dc0 [stack 0]
 Dot {
  name Dot20
  note_font "Bitstream Vera Sans"
  xpos 260
  ypos -670
 }
set N1aa15cb0 [stack 0]
 Dot {
  name Dot21
  note_font "Bitstream Vera Sans"
  xpos 121
  ypos -670
 }
 Group {
  name ZCAM_GamutBoundaryBlink2
  note_font "Bitstream Vera Sans"
  xpos 87
  ypos -600
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionM}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   illuminant_out {{parent.parent.white}}
   primary_out {{parent.parent.gamut}}
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1aa65ba0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1aa6ab00 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1aa6ab00
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1aa65ba0
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
set N1aa1fa90 [stack 0]
 Dot {
  name Dot22
  note_font "Bitstream Vera Sans"
  xpos 121
  ypos -519
 }
push $N1aa15cb0
push $N1aa1fa90
 Merge2 {
  inputs 2
  operation divide
  name Merge7
  xpos 226
  ypos -600
 }
 Expression {
  expr0 (r<thr.r||lim.r<1.0001||r>thr.r+s.r)?r:thr.r+s.r*pow(-(pow((r-thr.r)/s.r,p)/(pow((r-thr.r)/s.r,p)-1)),1/p)
  expr1 (g<thr.g||lim.g<1.0001||g>thr.g+s.g)?g:thr.g+s.g*pow(-(pow((g-thr.g)/s.g,p)/(pow((g-thr.g)/s.g,p)-1)),1/p)
  expr2 (b<thr.b||lim.b<1.0001||b>thr.b+s.b)?b:thr.b+s.b*pow(-(pow((b-thr.b)/s.b,p)/(pow((b-thr.b)/s.b,p)-1)),1/p)
  name UnCompress1
  label Power(P)
  xpos 226
  ypos -565
  addUserKnob {20 Params_tab l Params}
  addUserKnob {18 thr}
  thr {{parent.compressionM.0}}
  addUserKnob {6 thr_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 lim}
  lim {{parent.compressionM.1}}
  addUserKnob {6 lim_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 s}
  s {{(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)} {(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)} {(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)}}
  addUserKnob {6 s_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {7 p R 1 5}
  p {{parent.compressionM.2}}
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge8
  xpos 226
  ypos -522
 }
push $N1aa10dc0
 ShuffleCopy {
  inputs 2
  green green
  alpha alpha2
  name ShuffleCopy3
  label "Apply UnCompressed\nColourfulness (M)"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos -534
  disable {{!parent.applyGamutMappingM}}
 }
 Dot {
  name Dot3
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos -359
 }
set N1ab29070 [stack 0]
 Dot {
  name Dot14
  note_font "Bitstream Vera Sans"
  xpos 294
  ypos -359
 }
set N1ab2df50 [stack 0]
 Dot {
  name Dot24
  note_font "Bitstream Vera Sans"
  xpos -72
  ypos -359
 }
set N1ab32e40 [stack 0]
 Dot {
  name Dot25
  note_font "Bitstream Vera Sans"
  xpos -163
  ypos -359
 }
set N1ab37d30 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle6
  label "clear to white"
  note_font "Bitstream Vera Sans"
  xpos -423
  ypos -368
 }
 Colorspace {
  illuminant_in {{parent.illuminant_out}}
  primary_in {{parent.primary_out}}
  colorspace_out CIE-XYZ
  name Colorspace6
  label "Output White to XYZ"
  xpos -423
  ypos -332
 }
 Multiply {
  channels rgb
  value {{parent.ssts_luminance.1}}
  name Multiply29
  label "scale to SSTS\nmid luminance"
  note_font "Bitstream Vera Sans"
  xpos -423
  ypos -300
 }
 Group {
  name ZCAM_JMh_Blink4
  label "XYZ to JMh\nno drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -423
  ypos -252
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.white}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1ab87f80 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1ab8cea0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1ab8cea0
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1ab87f80
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Dot {
  name Dot60
  note_font "Bitstream Vera Sans"
  xpos -389
  ypos -199
 }
set N1ac00570 [stack 0]
 Dot {
  name Dot61
  note_font "Bitstream Vera Sans"
  xpos 42
  ypos -199
 }
 Dot {
  name Dot62
  note_font "Bitstream Vera Sans"
  xpos 42
  ypos -173
 }
push $N1ac00570
 Dot {
  name Dot47
  note_font "Bitstream Vera Sans"
  xpos -389
  ypos -173
 }
push $N1ab37d30
 Group {
  name ZCAM_GamutBoundaryBlink5
  note_font "Bitstream Vera Sans"
  xpos -197
  ypos -269
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionJ}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
  outputCusps true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1ac59e10 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1ac5ed50 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1ac5ed50
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1ac59e10
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
 Dot {
  name Dot55
  note_font "Bitstream Vera Sans"
  xpos -163
  ypos -219
 }
set N1acb6460 [stack 0]
 Dot {
  name Dot57
  note_font "Bitstream Vera Sans"
  xpos -257
  ypos -219
 }
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy8
  note_font "Bitstream Vera Sans"
  xpos -291
  ypos -176
 }
push $N1acb6460
 Switch {
  inputs 2
  which {{parent.focusTarget}}
  name Switch7
  note_font "Bitstream Vera Sans"
  xpos -197
  ypos -176
 }
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply19
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -197
  ypos -132
 }
 Dot {
  name Dot34
  note_font "Bitstream Vera Sans"
  xpos -163
  ypos -75
 }
push $N1ab32e40
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply3
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -106
  ypos -132
 }
 MergeExpression {
  inputs 2
  temp_name0 v
  temp_expr0 Bg/Ab
  temp_name1 relThreshold
  temp_expr1 max(0,threshold*Ag/Ab)
  temp_name2 s
  temp_expr2 (limit-relThreshold)/pow(pow((1-relThreshold)/(limit-relThreshold),-power)-1,1/power)
  temp_name3 compressed
  temp_expr3 (v<relThreshold||limit<1.0001)?v:relThreshold+s*((v-relThreshold)/s)/(pow(1+pow((v-relThreshold)/s,power),1/power))
  expr0 (Br-Ar*cuspFocus)*(v/compressed)+Ar*cuspFocus
  name MergeExpression1
  label "Compress to Cusp"
  note_font "Bitstream Vera Sans"
  xpos -106
  ypos -84
  addUserKnob {20 User}
  addUserKnob {7 threshold}
  threshold {{parent.compressionJ.0}}
  addUserKnob {7 limit R 1 10}
  limit {{parent.compressionJ.1}}
  addUserKnob {7 power R 0 3}
  power {{parent.compressionJ.2}}
  addUserKnob {7 cuspFocus R 0 2}
  cuspFocus {{parent.focusScale}}
 }
 Multiply {
  channels rgb
  value {{parent.reference_luminance} 1 1 1}
  name Multiply7
  label "De-Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -106
  ypos -48
 }
 Dot {
  name Dot36
  note_font "Bitstream Vera Sans"
  xpos 60
  ypos -33
 }
 Dot {
  name Dot39
  note_font "Bitstream Vera Sans"
  xpos 60
  ypos -271
 }
 Group {
  name ZCAM_GamutBoundaryBlink6
  note_font "Bitstream Vera Sans"
  xpos 170
  ypos -274
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionJ}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
  outputCusps true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1ad80b40 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1ad85aa0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1ad85aa0
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1ad80b40
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
 Dot {
  name Dot58
  note_font "Bitstream Vera Sans"
  xpos 204
  ypos -231
 }
set N1addd1b0 [stack 0]
 Dot {
  name Dot59
  note_font "Bitstream Vera Sans"
  xpos 110
  ypos -231
 }
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy9
  note_font "Bitstream Vera Sans"
  xpos 76
  ypos -176
 }
push $N1addd1b0
 Switch {
  inputs 2
  which {{parent.focusTarget}}
  name Switch8
  note_font "Bitstream Vera Sans"
  xpos 170
  ypos -176
 }
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply20
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos 170
  ypos -151
 }
 Dot {
  name Dot12
  note_font "Bitstream Vera Sans"
  xpos 204
  ypos -94
 }
push $N1ab2df50
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply27
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos 260
  ypos -151
 }
 MergeExpression {
  inputs 2
  temp_name0 v
  temp_expr0 Bg/Ab
  temp_name1 relThreshold
  temp_expr1 max(0,threshold*Ag/Ab)
  temp_name2 s
  temp_expr2 (limit-relThreshold)/pow(pow((1-relThreshold)/(limit-relThreshold),-power)-1,1/power)
  temp_name3 compressed
  temp_expr3 (v<relThreshold||limit<1.0001)?v:relThreshold+s*((v-relThreshold)/s)/(pow(1+pow((v-relThreshold)/s,power),1/power))
  expr0 (Br-Ar*cuspFocus)*(v/compressed)+Ar*cuspFocus
  name MergeExpression3
  label "Compress to Cusp"
  note_font "Bitstream Vera Sans"
  xpos 260
  ypos -103
  addUserKnob {20 User}
  addUserKnob {7 threshold}
  threshold {{parent.compressionJ.0}}
  addUserKnob {7 limit R 1 10}
  limit {{parent.compressionJ.1}}
  addUserKnob {7 power R 0 3}
  power {{parent.compressionJ.2}}
  addUserKnob {7 cuspFocus R 0 2}
  cuspFocus {{parent.focusScale}}
 }
 Multiply {
  channels rgb
  value {{parent.reference_luminance} 1 1 1}
  name Multiply28
  label "De-Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos 260
  ypos -67
 }
push $N1ab29070
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy6
  label "Apply UnCompressed\nLightness (J)"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos -67
  disable {{!parent.applyGamutMappingJ}}
 }
 Group {
  name Group2
  label "Re-Generate Iz\nfrom J"
  xpos 450
  ypos 48
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{ZCAM_IzMh_Blink1.referenceWhite}}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 10000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{ZCAM_IzMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 200}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {20 Factors}
  addUserKnob {7 F}
  F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
  addUserKnob {7 F_s}
  F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
  addUserKnob {7 L_A}
  L_A {{"referenceLuminance * backgroundLuminance / 100"}}
  addUserKnob {7 F_b}
  F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
  addUserKnob {7 F_L}
  F_L {{"0.171*pow(L_A, 1/3) * (1-exp(-48/9*L_A))"}}
 }
  BackdropNode {
   inputs 0
   name BackdropNode7
   tile_color 0x666666ff
   label "Reference White"
   note_font_size 20
   xpos 27
   ypos -149
   bdwidth 177
   bdheight 144
  }
  Input {
   inputs 0
   name Input
   xpos -66
   ypos -264
  }
  Dot {
   name Dot1
   xpos -32
   ypos -184
  }
set N1ae7fdc0 [stack 0]
  Dot {
   name Dot11
   xpos 114
   ypos -184
  }
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 80
   ypos -112
  }
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name Colorspace2
   xpos 80
   ypos -76
  }
  Expression {
   temp_name0 gain
   temp_expr0 parent.referenceLuminance/g
   expr0 r*gain
   expr1 g*gain
   expr2 b*gain
   name Expression0
   xpos 80
   ypos -50
  }
  Group {
   name XYZ_w_to_Izazbz
   xpos 80
   ypos -26
  }
   Input {
    inputs 0
    name Input1
    xpos 148
    ypos 197
   }
   Expression {
    temp_name0 cb
    temp_expr0 1.15
    temp_name1 cg
    temp_expr1 0.66
    expr0 "(cb*r) - ((cb-1)*b)"
    expr1 "(cg*g) - ((cg-1)*r)"
    expr2 b
    name Expression1
    label "XYZ (D65)\nto\nX'Y'Z (D65)"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 237
   }
   ColorMatrix {
    matrix {
        {0.41478972 0.579999 0.014648}
        {-0.20151 1.120649 0.0531008}
        {-0.0166008 0.2648 0.6684799}
      }
    name ColorMatrix1
    label "X'Y'Z (D65)\nto\nLMS"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 297
   }
   Expression {
    temp_name0 c1
    temp_expr0 "3424 / pow(2,12)"
    temp_name1 c2
    temp_expr1 "2413 / pow(2,7)"
    temp_name2 c3
    temp_expr2 "2392 / pow(2,7)"
    temp_name3 n
    temp_expr3 2610/pow(2,14)
    expr0 "pow( ( c1 + c2 * pow((r/10000),n) ) / ( 1 + c3 * pow((r/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    expr1 "pow( ( c1 + c2 * pow((g/10000),n) ) / ( 1 + c3 * pow((g/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    expr2 "pow( ( c1 + c2 * pow((b/10000),n) ) / ( 1 + c3 * pow((b/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    name Expression2
    label "LMS\nto\nL'M'S'"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 357
   }
   ColorMatrix {
    matrix {
        {0 {1-epsilon} 0}
        {3.524 -4.066708 0.542708}
        {0.199076 1.096799 -1.295875}
      }
    name ColorMatrix2
    label "L'M'S\nto\nIzazbz"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 417
    addUserKnob {20 User}
    addUserKnob {7 epsilon}
    epsilon 3.703522621e-11
   }
   Output {
    name Output1
    xpos 148
    ypos 517
   }
  end_group
  Dot {
   name Dot2
   xpos 114
   ypos 53
  }
push $N1ae7fdc0
  MergeExpression {
   inputs 2
   temp_name0 Qzm
   temp_expr0 "pow(parent.F_s, 2.2) * pow(parent.F_b, 0.5) * pow(parent.F_L, 0.2)"
   temp_name1 Qzw
   temp_expr1 "2700 * pow(Ar, (1.6 * parent.F_s) / pow(parent.F_b, 0.12)) * Qzm"
   temp_name2 Izp
   temp_expr2 "pow(parent.F_b, 0.12) / (1.6 * parent.F_s)"
   temp_name3 Izd
   temp_expr3 "2700 * 100 * Qzm"
   expr0 "pow((r * Qzw) / Izd, Izp)"
   channel1 none
   channel2 none
   channel3 none
   name MergeExpression3
   xpos -66
   ypos 50
  }
  Output {
   name Output
   xpos -66
   ypos 117
  }
 end_group
 Dot {
  name Dot45
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos 98
 }
set N1af201f0 [stack 0]
 Dot {
  name Dot9
  note_font "Bitstream Vera Sans"
  xpos 643
  ypos 98
 }
set N1af250e0 [stack 0]
 Group {
  name st2048_6
  label "Lum to PQ (ZCAM)\ninverse"
  xpos 609
  ypos 126
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  direction "ST.2048 -> Luminance (Cd/sqm)"
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1af39110 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1af39110
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Multiply {
  channels rgb
  value 1.028552621
  name Multiply16
  label "re-apply luminance shift\nfrom cone fundamentals matrix\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 609
  ypos 168
 }
set N1af764a0 [stack 0]
 BlinkScript {
  recompileCount 35
  ProgramGroup 1
  KernelDescription "2 \"SSTSKernel\" iterate pixelWise 3292521f65973146de9ba2803e15c81b8610684f8dcbef3a3fc1382de44823f8 2 \"src\" Read Point \"dst\" Write Point 8 \"lumMid\" Float 1 AAAAAA== \"defaultMin\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMid\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMax\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"coefsLow\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"coefsHigh\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"M1\" Float 9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inverse\" Int 1 AAAAAA== 8 \"lumMid\" 1 1 \"defaultMin\" 3 1 \"defaultMid\" 3 1 \"defaultMax\" 3 1 \"coefsLow\" 1 6 \"coefsHigh\" 1 6 \"M1\" 9 1 \"inverse\" 1 1 4 \"expShift\" Float 1 1 AAAAAA== \"paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel SSTSKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float lumMid;\n    float3 defaultMin;\n    float3 defaultMid;\n    float3 defaultMax;\n    float coefsLow\[6];\n    float coefsHigh\[6];\n    float3x3 M1;\n    int inverse;\n\n  local:\n    float expShift;\n    float3 paramMin;\n    float3 paramMid;\n    float3 paramMax;\n\n  \n  void define()\n  \{\n\n  \}\n\n  float3 vector_dot( float3 v, float3x3 m)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float dot( float3 a, float3 b)\n  \{\n    return (a.x*b.x) + (a.y*b.y) + (a.z*b.z);\n  \}\n\n  \n  float ssts(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float HALF_MIN = 0.0000000596046448;\n\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsLow\[j], coefsLow\[j + 1], coefsLow\[j + 2]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsHigh\[j], coefsHigh\[j + 1], coefsHigh\[j + 2]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return pow(10.0f,logy);\n  \}\n\n  \n  float inv_ssts(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( coefsLow\[i] + coefsLow\[i+1]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( coefsHigh\[i] + coefsHigh\[i+1]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = coefsLow\[0];\n          cf.y = coefsLow\[1];\n          cf.z = coefsLow\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = coefsLow\[1];\n          cf.y = coefsLow\[2];\n          cf.z = coefsLow\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = coefsLow\[2];\n          cf.y = coefsLow\[3];\n          cf.z = coefsLow\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1 );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = coefsHigh\[0];\n          cf.y = coefsHigh\[1];\n          cf.z = coefsHigh\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = coefsHigh\[1];\n          cf.y = coefsHigh\[2];\n          cf.z = coefsHigh\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = coefsHigh\[2];\n          cf.y = coefsHigh\[3];\n          cf.z = coefsHigh\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1);\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return pow(10.0f, logx);\n  \}\n\n\n  void init()\n  \{\n    paramMin = defaultMin;\n    paramMid = defaultMid;\n    paramMax = defaultMax;\n    expShift = log2(inv_ssts(lumMid, defaultMin, paramMid, defaultMax)) - log2(0.18f);\n    paramMin.x = pow(2.0f, (log(paramMin.x) / log(2.0f) - expShift));\n    paramMid.x = pow(2.0f, (log(0.18f     ) / log(2.0f) - expShift));\n    paramMax.x = pow(2.0f, (log(paramMax.x) / log(2.0f) - expShift));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    float3 srcPixel(input.x, input.y, input.z);\n    float3 tsPixel = 0.0f;\n\n    if( inverse )\n    \{\n      tsPixel.x = inv_ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = inv_ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = inv_ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n    else\n    \{\n      tsPixel.x = ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n\n    dst() = float4(tsPixel.x, tsPixel.y, tsPixel.z, input.w);\n  \}\n\};\n"
  rebuild ""
  SSTSKernel_lumMid {{luminances.y}}
  SSTSKernel_defaultMin {{pow(2.,(log(MIN_PT.x)/log(2)))} {MIN_PT.y} {MIN_PT.z}}
  SSTSKernel_defaultMid {{pow(2.,(log(0.18)/log(2)))} {MID_PT.y} {MID_PT.z}}
  SSTSKernel_defaultMax {{pow(2.,(log(MAX_PT.x)/log(2)))} {MAX_PT.y} {MAX_PT.z}}
  SSTSKernel_coefsLow {{"(MIN_PT.z * (log10(MIN_PT.x)-0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"(MIN_PT.z * (log10(MIN_PT.x)+0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"log10(MIN_PT.y) + pctLow*(log10(MID_PT.y)-log10(MIN_PT.y))"} {"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {SSTSKernel_coefsLow.4}}
  SSTSKernel_coefsHigh {{"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"log10(MID_PT.y) + pctHigh*(log10(MAX_PT.y)-log10(MID_PT.y))"} {"(MAX_PT.z * (log10(MAX_PT.x)-0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {"(MAX_PT.z * (log10(MAX_PT.x)+0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {SSTSKernel_coefsHigh.4}}
  SSTSKernel_M1 {
      {0.5 -1 0.5}
      {-1 1 0}
      {0.5 0.5 0}
    }
  SSTSKernel_inverse {{direction}}
  rebuild_finalise ""
  name SSTS_Blink3
  label inverse
  note_font "Bitstream Vera Sans"
  xpos 609
  ypos 228
  addUserKnob {20 User}
  addUserKnob {13 luminances}
  luminances {{parent.ssts_luminance.0} {parent.ssts_luminance.1} {parent.ssts_luminance.2}}
  addUserKnob {4 direction M {forward inverse}}
  direction inverse
  addUserKnob {20 SSTSParams}
  addUserKnob {13 MIN_PT}
  MIN_PT {{0.18*pow(2,minTable(log10(luminances.x)))} {luminances.x} 0}
  addUserKnob {13 MID_PT}
  MID_PT {0.18 4.8 1.55}
  addUserKnob {13 MAX_PT}
  MAX_PT {{0.18*pow(2,maxTable(log10(luminances.z)))} {luminances.z} 0}
  addUserKnob {7 knotIncLow}
  knotIncLow {{"(log10(MID_PT.x) - log10(MIN_PT.x)) / 3"}}
  addUserKnob {7 knotIncHigh}
  knotIncHigh {{"(log10(MAX_PT.x) - log10(MID_PT.x)) / 3"}}
  addUserKnob {7 pctLow}
  pctLow {{bendsLow(log(MIN_PT.x/0.18)/log(2))}}
  addUserKnob {7 pctHigh}
  pctHigh {{bendsHigh(log(MAX_PT.x/0.18)/log(2))}}
  addUserKnob {20 Tables}
  addUserKnob {7 minTable}
  minTable {{curve L l x-4 -15 x-1.69896996 -6.5}}
  addUserKnob {7 maxTable}
  maxTable {{curve L l x1.681241274 6.5 x4 18}}
  addUserKnob {7 bendsLow}
  bendsLow {{curve L l x-15 0.18 x-6.5 0.35}}
  addUserKnob {7 bendsHigh}
  bendsHigh {{curve l x6.5 0.89 x18 0.9}}
  addUserKnob {20 Constants}
  addUserKnob {7 MIN_STOP_SDR R -10 10}
  MIN_STOP_SDR -6.5
  addUserKnob {7 MAX_STOP_SDR R -10 10}
  MAX_STOP_SDR 6.5
  addUserKnob {7 MIN_STOP_RRT R -20 20}
  MIN_STOP_RRT -15
  addUserKnob {7 MAX_STOP_RRT R -20 20}
  MAX_STOP_RRT 18
  addUserKnob {7 MIN_LUM_SDR}
  MIN_LUM_SDR 0.02
  addUserKnob {7 MAX_LUM_SDR R 0 200}
  MAX_LUM_SDR 48
  addUserKnob {7 MIN_LUM_RRT}
  MIN_LUM_RRT 0.0001
  addUserKnob {7 MAX_LUM_RRT R 0 10000}
  MAX_LUM_RRT 10000
  addUserKnob {3 N_KNOTS_LOW}
  N_KNOTS_LOW 4
  addUserKnob {3 N_KNOTS_HIGH}
  N_KNOTS_HIGH 4
 }
set N1af82370 [stack 0]
 Multiply {
  channels rgb
  value {{parent.reference_luminance}}
  name Multiply15
  label "1/\[value parent.reference_luminance]\nLum to Exp\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 609
  ypos 276
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply14
  label "remove luminance shift\nfrom cone fundamentals matrix\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 609
  ypos 336
 }
 Group {
  name st2048_5
  label "PQ (ZCAM) to Lum\ninverse"
  xpos 609
  ypos 396
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1afd65d0 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1afd65d0
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
push $N1af201f0
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy4
  label "apply SSTS"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos 399
  disable {{!parent.applySSTS}}
 }
 Dot {
  name Dot38
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos 450
 }
set N1b0244f0 [stack 0]
 Dot {
  name Dot44
  note_font "Bitstream Vera Sans"
  xpos 605
  ypos 450
 }
set N1b0293c0 [stack 0]
push $N1af764a0
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance}}
  name Multiply21
  label "1/\[value parent.reference_luminance]\nLum to Exp\n"
  note_font "Bitstream Vera Sans"
  xpos 825
  ypos 174
 }
set N1b02e2b0 [stack 0]
 Dot {
  name Dot56
  note_font "Bitstream Vera Sans"
  xpos 1058
  ypos 189
 }
push $N1af82370
 Switch {
  inputs 2
  which {{!parent.applySSTS}}
  name Switch4
  label "dont apply inverse SSTS\nif it has been disabled"
  note_font "Bitstream Vera Sans"
  xpos 1024
  ypos 228
 }
 Expression {
  expr0 "r>0.18 ? 1 : 0"
  name Expression1
  label "mask for values\nabove mid-SSTS"
  note_font "Bitstream Vera Sans"
  xpos 1024
  ypos 282
 }
 Dot {
  name Dot37
  note_font "Bitstream Vera Sans"
  xpos 1058
  ypos 424
 }
push $N1b0293c0
 Dot {
  name Dot52
  note_font "Bitstream Vera Sans"
  xpos 788
  ypos 450
 }
 Dot {
  name Dot53
  note_font "Bitstream Vera Sans"
  xpos 788
  ypos 80
 }
 Dot {
  name Dot46
  note_font "Bitstream Vera Sans"
  xpos 1164
  ypos 80
 }
set N1b064880 [stack 0]
 Shuffle {
  red black
  green black
  blue black
  alpha black
  name Shuffle4
  label "all to zero"
  note_font "Bitstream Vera Sans"
  xpos 1342
  ypos 71
 }
 Dot {
  name Dot48
  note_font "Bitstream Vera Sans"
  xpos 1376
  ypos 124
 }
set N1b079ff0 [stack 0]
 Dot {
  name Dot49
  note_font "Bitstream Vera Sans"
  xpos 1309
  ypos 124
 }
 Add {
  channels rgb
  value {{parent.ssts_luminance.1}}
  name Add1
  label "Set to post-SSTS\nMid-Luminance"
  note_font "Bitstream Vera Sans"
  xpos 1275
  ypos 151
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply23
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos 1275
  ypos 213
 }
 Group {
  name st2048_7
  label "Lum to PQ (ZCAM)"
  xpos 1275
  ypos 263
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1b0ab060 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1b0ab060
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
push $N1b079ff0
 Dot {
  name Dot50
  note_font "Bitstream Vera Sans"
  xpos 1445
  ypos 124
 }
 Add {
  channels rgb
  value 18
  name Add3
  label "Set to pre-SSTS\nMid-Luminance"
  note_font "Bitstream Vera Sans"
  xpos 1411
  ypos 156
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply24
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos 1411
  ypos 215
 }
 Group {
  name st2048_8
  label "Lum to PQ (ZCAM)"
  xpos 1411
  ypos 263
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1b1141e0 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1b1141e0
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Dot {
  name Dot51
  note_font "Bitstream Vera Sans"
  xpos 1445
  ypos 324
 }
 Merge2 {
  inputs 2
  operation minus
  name Merge13
  note_font "Bitstream Vera Sans"
  xpos 1275
  ypos 321
 }
push $N1b064880
 Merge2 {
  inputs 2
  operation plus
  name Merge14
  label "add offset to\nalign mids"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 309
 }
push $N1b02e2b0
 BlinkScript {
  recompileCount 35
  ProgramGroup 1
  KernelDescription "2 \"SSTSKernel\" iterate pixelWise 3292521f65973146de9ba2803e15c81b8610684f8dcbef3a3fc1382de44823f8 2 \"src\" Read Point \"dst\" Write Point 8 \"lumMid\" Float 1 AAAAAA== \"defaultMin\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMid\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMax\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"coefsLow\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"coefsHigh\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"M1\" Float 9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inverse\" Int 1 AAAAAA== 8 \"lumMid\" 1 1 \"defaultMin\" 3 1 \"defaultMid\" 3 1 \"defaultMax\" 3 1 \"coefsLow\" 1 6 \"coefsHigh\" 1 6 \"M1\" 9 1 \"inverse\" 1 1 4 \"expShift\" Float 1 1 AAAAAA== \"paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel SSTSKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float lumMid;\n    float3 defaultMin;\n    float3 defaultMid;\n    float3 defaultMax;\n    float coefsLow\[6];\n    float coefsHigh\[6];\n    float3x3 M1;\n    int inverse;\n\n  local:\n    float expShift;\n    float3 paramMin;\n    float3 paramMid;\n    float3 paramMax;\n\n  \n  void define()\n  \{\n\n  \}\n\n  float3 vector_dot( float3 v, float3x3 m)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float dot( float3 a, float3 b)\n  \{\n    return (a.x*b.x) + (a.y*b.y) + (a.z*b.z);\n  \}\n\n  \n  float ssts(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float HALF_MIN = 0.0000000596046448;\n\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsLow\[j], coefsLow\[j + 1], coefsLow\[j + 2]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsHigh\[j], coefsHigh\[j + 1], coefsHigh\[j + 2]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return pow(10.0f,logy);\n  \}\n\n  \n  float inv_ssts(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( coefsLow\[i] + coefsLow\[i+1]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( coefsHigh\[i] + coefsHigh\[i+1]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = coefsLow\[0];\n          cf.y = coefsLow\[1];\n          cf.z = coefsLow\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = coefsLow\[1];\n          cf.y = coefsLow\[2];\n          cf.z = coefsLow\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = coefsLow\[2];\n          cf.y = coefsLow\[3];\n          cf.z = coefsLow\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1 );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = coefsHigh\[0];\n          cf.y = coefsHigh\[1];\n          cf.z = coefsHigh\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = coefsHigh\[1];\n          cf.y = coefsHigh\[2];\n          cf.z = coefsHigh\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = coefsHigh\[2];\n          cf.y = coefsHigh\[3];\n          cf.z = coefsHigh\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1);\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return pow(10.0f, logx);\n  \}\n\n\n  void init()\n  \{\n    paramMin = defaultMin;\n    paramMid = defaultMid;\n    paramMax = defaultMax;\n    expShift = log2(inv_ssts(lumMid, defaultMin, paramMid, defaultMax)) - log2(0.18f);\n    paramMin.x = pow(2.0f, (log(paramMin.x) / log(2.0f) - expShift));\n    paramMid.x = pow(2.0f, (log(0.18f     ) / log(2.0f) - expShift));\n    paramMax.x = pow(2.0f, (log(paramMax.x) / log(2.0f) - expShift));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    float3 srcPixel(input.x, input.y, input.z);\n    float3 tsPixel = 0.0f;\n\n    if( inverse )\n    \{\n      tsPixel.x = inv_ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = inv_ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = inv_ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n    else\n    \{\n      tsPixel.x = ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n\n    dst() = float4(tsPixel.x, tsPixel.y, tsPixel.z, input.w);\n  \}\n\};\n"
  rebuild ""
  SSTSKernel_lumMid {{luminances.y}}
  SSTSKernel_defaultMin {{pow(2.,(log(MIN_PT.x)/log(2)))} {MIN_PT.y} {MIN_PT.z}}
  SSTSKernel_defaultMid {{pow(2.,(log(0.18)/log(2)))} {MID_PT.y} {MID_PT.z}}
  SSTSKernel_defaultMax {{pow(2.,(log(MAX_PT.x)/log(2)))} {MAX_PT.y} {MAX_PT.z}}
  SSTSKernel_coefsLow {{"(MIN_PT.z * (log10(MIN_PT.x)-0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"(MIN_PT.z * (log10(MIN_PT.x)+0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"log10(MIN_PT.y) + pctLow*(log10(MID_PT.y)-log10(MIN_PT.y))"} {"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {SSTSKernel_coefsLow.4}}
  SSTSKernel_coefsHigh {{"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"log10(MID_PT.y) + pctHigh*(log10(MAX_PT.y)-log10(MID_PT.y))"} {"(MAX_PT.z * (log10(MAX_PT.x)-0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {"(MAX_PT.z * (log10(MAX_PT.x)+0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {SSTSKernel_coefsHigh.4}}
  SSTSKernel_M1 {
      {0.5 -1 0.5}
      {-1 1 0}
      {0.5 0.5 0}
    }
  SSTSKernel_inverse {{direction}}
  rebuild_finalise ""
  name SSTS_Blink1
  note_font "Bitstream Vera Sans"
  xpos 825
  ypos 297
  addUserKnob {20 User}
  addUserKnob {13 luminances}
  luminances {{parent.ssts_luminance.0} {parent.ssts_luminance.1} {parent.ssts_luminance.2}}
  addUserKnob {4 direction M {forward inverse}}
  addUserKnob {20 SSTSParams}
  addUserKnob {13 MIN_PT}
  MIN_PT {{0.18*pow(2,minTable(log10(luminances.x)))} {luminances.x} 0}
  addUserKnob {13 MID_PT}
  MID_PT {0.18 4.8 1.55}
  addUserKnob {13 MAX_PT}
  MAX_PT {{0.18*pow(2,maxTable(log10(luminances.z)))} {luminances.z} 0}
  addUserKnob {7 knotIncLow}
  knotIncLow {{"(log10(MID_PT.x) - log10(MIN_PT.x)) / 3"}}
  addUserKnob {7 knotIncHigh}
  knotIncHigh {{"(log10(MAX_PT.x) - log10(MID_PT.x)) / 3"}}
  addUserKnob {7 pctLow}
  pctLow {{bendsLow(log(MIN_PT.x/0.18)/log(2))}}
  addUserKnob {7 pctHigh}
  pctHigh {{bendsHigh(log(MAX_PT.x/0.18)/log(2))}}
  addUserKnob {20 Tables}
  addUserKnob {7 minTable}
  minTable {{curve L l x-4 -15 x-1.69896996 -6.5}}
  addUserKnob {7 maxTable}
  maxTable {{curve L l x1.681241274 6.5 x4 18}}
  addUserKnob {7 bendsLow}
  bendsLow {{curve L l x-15 0.18 x-6.5 0.35}}
  addUserKnob {7 bendsHigh}
  bendsHigh {{curve l x6.5 0.89 x18 0.9}}
  addUserKnob {20 Constants}
  addUserKnob {7 MIN_STOP_SDR R -10 10}
  MIN_STOP_SDR -6.5
  addUserKnob {7 MAX_STOP_SDR R -10 10}
  MAX_STOP_SDR 6.5
  addUserKnob {7 MIN_STOP_RRT R -20 20}
  MIN_STOP_RRT -15
  addUserKnob {7 MAX_STOP_RRT R -20 20}
  MAX_STOP_RRT 18
  addUserKnob {7 MIN_LUM_SDR}
  MIN_LUM_SDR 0.02
  addUserKnob {7 MAX_LUM_SDR R 0 200}
  MAX_LUM_SDR 48
  addUserKnob {7 MIN_LUM_RRT}
  MIN_LUM_RRT 0.0001
  addUserKnob {7 MAX_LUM_RRT R 0 10000}
  MAX_LUM_RRT 10000
  addUserKnob {3 N_KNOTS_LOW}
  N_KNOTS_LOW 4
  addUserKnob {3 N_KNOTS_HIGH}
  N_KNOTS_HIGH 4
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply26
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos 825
  ypos 333
 }
 Group {
  name st2048_9
  label "Lum to PQ (ZCAM)"
  xpos 825
  ypos 381
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1b1bfbd0 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1b1bfbd0
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
push $N1af250e0
 Dot {
  name Dot54
  note_font "Bitstream Vera Sans"
  xpos 969
  ypos 98
 }
 Switch {
  inputs 2
  which {{!parent.applySSTS}}
  name Switch5
  label "apply forward SSTS\nif it has been disabled"
  note_font "Bitstream Vera Sans"
  xpos 935
  ypos 373
 }
 Merge2 {
  inputs 2
  operation minus
  name Merge15
  label "diff tonescale"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 379
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge16
  label "remove toe"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 415
 }
 Multiply {
  channels rgb
  value {{parent.desatHighlights}}
  name Multiply25
  label "desat scale"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 451
 }
 Group {
  name SoftclipExpression3
  label "avoid negative values for M"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 487
  addUserKnob {20 User}
  addUserKnob {18 clip_to}
  clip_to 0.9
  addUserKnob {6 clip_to_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 clip_to_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 clip_to_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 threshold}
  threshold 0.8
  addUserKnob {6 threshold_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {4 direction M {forward inverse}}
  addUserKnob {7 mix}
  mix 1
 }
  Input {
   inputs 0
   name Input1
   xpos -284
   ypos 135
  }
  Multiply {
   value {{1/parent.clip_to.r} {1/parent.clip_to.g} {1/parent.clip_to.b} 1}
   name Multiply1
   note_font "Bitstream Vera Sans"
   xpos -284
   ypos 159
  }
set N1b252790 [stack 0]
  Expression {
   temp_name0 one_minus_e
   temp_expr0 "1 - pow(10,-15)"
   temp_name1 maxr
   temp_expr1 "(pow(threshold.r, 2) - 2 * threshold.r * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   temp_name2 maxg
   temp_expr2 "(pow(threshold.g, 2) - 2 * threshold.g * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   temp_name3 maxb
   temp_expr3 "(pow(threshold.b, 2) - 2 * threshold.b * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   expr0 " threshold.r < 1 ? r >= 1 ? maxr : r > threshold.r ? (pow(threshold.r, 2) - 2 * threshold.r * r + r ) / ( 1 - r ) : r : r"
   expr1 " threshold.g < 1 ? g >= 1 ? maxg : g > threshold.g ? (pow(threshold.g, 2) - 2 * threshold.g * g + g ) / ( 1 - g ) : g : g"
   expr2 " threshold.b < 1 ? b >= 1 ? maxb : b > threshold.b ? (pow(threshold.b, 2) - 2 * threshold.b * b + b ) / ( 1 - b ) : b : b"
   expr3 a
   mix {{parent.mix}}
   name Expression2
   label inverse
   xpos -222
   ypos 257
   addUserKnob {20 User}
   addUserKnob {18 threshold}
   threshold {{parent.threshold.r} {parent.threshold.g} {parent.threshold.b}}
   addUserKnob {6 threshold_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  }
push $N1b252790
  Expression {
   expr0 "threshold.r < 1 ? r > threshold.r ? ( -1 / (( r - threshold.r ) / ( 1 - threshold.r ) +1 ) +1 ) * ( 1 - threshold.r ) + threshold.r : r : r"
   expr1 "threshold.g < 1 ? g > threshold.g ? ( -1 / (( g - threshold.g ) / ( 1 - threshold.g ) +1 ) +1 ) * ( 1 - threshold.g ) + threshold.g : g : g"
   expr2 "threshold.b < 1 ? b > threshold.b ? ( -1 / (( b - threshold.b ) / ( 1 - threshold.b ) +1 ) +1 ) * ( 1 - threshold.b ) + threshold.b : b : b"
   expr3 a
   mix {{parent.mix}}
   name Expression1
   label forward
   xpos -349
   ypos 258
   addUserKnob {20 User}
   addUserKnob {18 threshold_1 l threshold}
   threshold_1 {{parent.threshold.r} {parent.threshold.g} {parent.threshold.b}}
   addUserKnob {6 threshold_1_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   note_font "Bitstream Vera Sans"
   xpos -287
   ypos 356
  }
  Multiply {
   value {{parent.clip_to.r} {parent.clip_to.g} {parent.clip_to.b} 1}
   name Multiply2
   note_font "Bitstream Vera Sans"
   xpos -287
   ypos 380
  }
  Output {
   name Output1
   xpos -287
   ypos 463
  }
 end_group
 Clamp {
  channels rgb
  name Clamp4
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 523
 }
 Invert {
  channels rgb
  name Invert3
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 547
 }
 Shuffle {
  red white
  green red
  blue white
  alpha white
  name Shuffle5
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 571
 }
 Merge2 {
  inputs 2
  operation divide
  name Merge12
  label "highlight de-sat\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 571
  ypos 565
 }
push $N1b0244f0
 Switch {
  inputs 2
  which {{parent.applyHighlightDesat}}
  name Switch3
  label "apply\nhighlight desat"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos 565
 }
 Group {
  name ZCAM_IzMh_Blink3
  label "XYZ to IzMh"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos 696
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.illuminant_in}}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2048 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1b2f8090 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1b2fcfb0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1b2fcfb0
  Colorspace {
   illuminant_in {{parent.parent.illuminant_in}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 213
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1b2f8090
  BlinkScript {
   inputs 3
   recompileCount 70
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_IzMh_Kernel_v02\" iterate pixelWise 699a9a103a452f3a77c4ee9405f1b913eb2b3f7aefbddb2581496e804e75cd10 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_IzMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_IzMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 IzMh = 0.0f;\n\n    IzMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+IzMh.z));\n    IzMh.x = Izazbz.x;\n    IzMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return IzMh;\n  \}\n\n\n  float3 IzMh_to_Izazbz( float3 IzMh, float refWhiteIz)\n  \{\n    float ez = 1.015f + cos(radians(89.038f+IzMh.z));\n    float hzr = radians(IzMh.z);\n    float Czp = spow((IzMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * pow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( IzMh.x, Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_IzMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_IzMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_IzMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(IzMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_IzMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_IzMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_IzMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_IzMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_IzMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_IzMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_IzMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_IzMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_IzMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_IzMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_IzMh_Kernel_v02_L_A))"}}
   ZCAM_IzMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_IzMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_IzMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance}}
  name Multiply17
  label "x\[value parent.reference_luminance]\nRel. Exp. to Cd/sqm\ninverse"
  xpos 450
  ypos 737
  disable {{"Colorspace4.colorspace_out == 31"}}
 }
 Colorspace {
  colorspace_in CIE-XYZ
  colorspace_out {{Colorspace1.colorspace_in}}
  illuminant_out {{Colorspace1.illuminant_in}}
  primary_out {{Colorspace1.primary_in}}
  name Colorspace4
  label "XYZ -> Input"
  xpos 450
  ypos 789
 }
 Dot {
  name Dot30
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos 909
 }
 Dot {
  name Dot29
  note_font "Bitstream Vera Sans"
  xpos -461
  ypos 909
 }
push $N1a953ba0
 Dot {
  name Dot16
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos -1035
 }
 Clamp {
  channels rgb
  minimum -65504
  minimum_enable false
  maximum 65504
  name Clamp1
  label "Clamp inf to\n+/-half max"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos -909
 }
 Colorspace {
  illuminant_in ACES
  primary_in ACES
  colorspace_out CIE-XYZ
  name Colorspace1
  label "Input -> XYZ"
  xpos -1148
  ypos -859
 }
 Multiply {
  channels rgb
  value {{parent.reference_luminance}}
  name Multiply1
  label "x\[value parent.reference_luminance]\nRel. Exp. to Cd/sqm"
  xpos -1148
  ypos -818
  disable {{"Colorspace1.colorspace_in == 31"}}
 }
 Group {
  name ZCAM_IzMh_Blink1
  label "XYZ to IzMh"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos -768
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.illuminant_in}}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2048 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1b3eb010 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1b3eff30 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1b3eff30
  Colorspace {
   illuminant_in {{parent.parent.illuminant_in}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 213
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1b3eb010
  BlinkScript {
   inputs 3
   recompileCount 70
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_IzMh_Kernel_v02\" iterate pixelWise 699a9a103a452f3a77c4ee9405f1b913eb2b3f7aefbddb2581496e804e75cd10 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_IzMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_IzMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 IzMh = 0.0f;\n\n    IzMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+IzMh.z));\n    IzMh.x = Izazbz.x;\n    IzMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return IzMh;\n  \}\n\n\n  float3 IzMh_to_Izazbz( float3 IzMh, float refWhiteIz)\n  \{\n    float ez = 1.015f + cos(radians(89.038f+IzMh.z));\n    float hzr = radians(IzMh.z);\n    float Czp = spow((IzMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * pow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( IzMh.x, Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_IzMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_IzMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_IzMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(IzMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_IzMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_IzMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_IzMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_IzMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_IzMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_IzMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_IzMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_IzMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_IzMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_IzMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_IzMh_Kernel_v02_L_A))"}}
   ZCAM_IzMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_IzMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_IzMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Dot {
  name Dot5
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos -603
 }
set N1b461410 [stack 0]
 Dot {
  name Dot11
  note_font "Bitstream Vera Sans"
  xpos -1309
  ypos -603
 }
set N1b466300 [stack 0]
 Group {
  name st2048_3
  label "PQ (ZCAM) to Lum"
  xpos -1343
  ypos -480
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  direction "ST.2048 -> Luminance (Cd/sqm)"
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1b47a120 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1b47a120
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Multiply {
  channels rgb
  value 1.028552621
  name Multiply10
  label "remove luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos -1343
  ypos -448
 }
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance}}
  name Multiply11
  label "1/\[value parent.reference_luminance]\nLum to Exp"
  note_font "Bitstream Vera Sans"
  xpos -1343
  ypos -400
 }
set N1b4c3390 [stack 0]
 Expression {
  expr0 "r>0.18 ? 1 : 0"
  name Expression5
  label "mask for values\nabove mid-SSTS"
  note_font "Bitstream Vera Sans"
  xpos -1453
  ypos -400
 }
 Dot {
  name Dot8
  note_font "Bitstream Vera Sans"
  xpos -1419
  ypos -282
 }
push $N1b466300
 Dot {
  name Dot7
  note_font "Bitstream Vera Sans"
  xpos -1608
  ypos -603
 }
set N1b4e2930 [stack 0]
 Shuffle {
  red black
  green black
  blue black
  alpha black
  name Shuffle3
  label "all to zero"
  note_font "Bitstream Vera Sans"
  xpos -1813
  ypos -612
 }
 Dot {
  name Dot43
  note_font "Bitstream Vera Sans"
  xpos -1779
  ypos -576
 }
set N1b4f80a0 [stack 0]
 Dot {
  name Dot42
  note_font "Bitstream Vera Sans"
  xpos -1718
  ypos -576
 }
 Add {
  channels rgb
  value {{parent.ssts_luminance.1}}
  name Add4
  label "Set to post-SSTS\nMid-Luminance"
  note_font "Bitstream Vera Sans"
  xpos -1752
  ypos -549
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply9
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos -1752
  ypos -487
 }
 Group {
  name st2048_1
  label "Lum to PQ (ZCAM)"
  xpos -1752
  ypos -437
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1b529510 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1b529510
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
push $N1b4f80a0
 Dot {
  name Dot41
  note_font "Bitstream Vera Sans"
  xpos -1824
  ypos -576
 }
 Add {
  channels rgb
  value 18
  name Add5
  label "Set to pre-SSTS\nMid-Luminance"
  note_font "Bitstream Vera Sans"
  xpos -1858
  ypos -544
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply18
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos -1858
  ypos -485
 }
 Group {
  name st2048_2
  label "Lum to PQ (ZCAM)"
  xpos -1858
  ypos -437
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1b592690 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1b592690
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Dot {
  name Dot35
  note_font "Bitstream Vera Sans"
  xpos -1824
  ypos -402
 }
 Merge2 {
  inputs 2
  operation minus
  name Merge5
  note_font "Bitstream Vera Sans"
  xpos -1752
  ypos -405
 }
push $N1b4e2930
 Merge2 {
  inputs 2
  operation plus
  name Merge11
  label "add offset to\nalign mids"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -417
 }
 Expression {
  temp_name0 HALF_MIN
  temp_expr0 0.0000000596046448
  expr0 log10(max(HALF_MIN,r))
  channel1 none
  channel2 none
  channel3 none
  name Expression3
  label log10
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -369
 }
push $N1b4c3390
 BlinkScript {
  recompileCount 35
  ProgramGroup 1
  KernelDescription "2 \"SSTSKernel\" iterate pixelWise 3292521f65973146de9ba2803e15c81b8610684f8dcbef3a3fc1382de44823f8 2 \"src\" Read Point \"dst\" Write Point 8 \"lumMid\" Float 1 AAAAAA== \"defaultMin\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMid\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMax\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"coefsLow\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"coefsHigh\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"M1\" Float 9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inverse\" Int 1 AAAAAA== 8 \"lumMid\" 1 1 \"defaultMin\" 3 1 \"defaultMid\" 3 1 \"defaultMax\" 3 1 \"coefsLow\" 1 6 \"coefsHigh\" 1 6 \"M1\" 9 1 \"inverse\" 1 1 4 \"expShift\" Float 1 1 AAAAAA== \"paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel SSTSKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float lumMid;\n    float3 defaultMin;\n    float3 defaultMid;\n    float3 defaultMax;\n    float coefsLow\[6];\n    float coefsHigh\[6];\n    float3x3 M1;\n    int inverse;\n\n  local:\n    float expShift;\n    float3 paramMin;\n    float3 paramMid;\n    float3 paramMax;\n\n  \n  void define()\n  \{\n\n  \}\n\n  float3 vector_dot( float3 v, float3x3 m)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float dot( float3 a, float3 b)\n  \{\n    return (a.x*b.x) + (a.y*b.y) + (a.z*b.z);\n  \}\n\n  \n  float ssts(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float HALF_MIN = 0.0000000596046448;\n\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsLow\[j], coefsLow\[j + 1], coefsLow\[j + 2]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsHigh\[j], coefsHigh\[j + 1], coefsHigh\[j + 2]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return pow(10.0f,logy);\n  \}\n\n  \n  float inv_ssts(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( coefsLow\[i] + coefsLow\[i+1]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( coefsHigh\[i] + coefsHigh\[i+1]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = coefsLow\[0];\n          cf.y = coefsLow\[1];\n          cf.z = coefsLow\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = coefsLow\[1];\n          cf.y = coefsLow\[2];\n          cf.z = coefsLow\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = coefsLow\[2];\n          cf.y = coefsLow\[3];\n          cf.z = coefsLow\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1 );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = coefsHigh\[0];\n          cf.y = coefsHigh\[1];\n          cf.z = coefsHigh\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = coefsHigh\[1];\n          cf.y = coefsHigh\[2];\n          cf.z = coefsHigh\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = coefsHigh\[2];\n          cf.y = coefsHigh\[3];\n          cf.z = coefsHigh\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1);\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return pow(10.0f, logx);\n  \}\n\n\n  void init()\n  \{\n    paramMin = defaultMin;\n    paramMid = defaultMid;\n    paramMax = defaultMax;\n    expShift = log2(inv_ssts(lumMid, defaultMin, paramMid, defaultMax)) - log2(0.18f);\n    paramMin.x = pow(2.0f, (log(paramMin.x) / log(2.0f) - expShift));\n    paramMid.x = pow(2.0f, (log(0.18f     ) / log(2.0f) - expShift));\n    paramMax.x = pow(2.0f, (log(paramMax.x) / log(2.0f) - expShift));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    float3 srcPixel(input.x, input.y, input.z);\n    float3 tsPixel = 0.0f;\n\n    if( inverse )\n    \{\n      tsPixel.x = inv_ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = inv_ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = inv_ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n    else\n    \{\n      tsPixel.x = ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n\n    dst() = float4(tsPixel.x, tsPixel.y, tsPixel.z, input.w);\n  \}\n\};\n"
  rebuild ""
  SSTSKernel_lumMid {{luminances.y}}
  SSTSKernel_defaultMin {{pow(2.,(log(MIN_PT.x)/log(2)))} {MIN_PT.y} {MIN_PT.z}}
  SSTSKernel_defaultMid {{pow(2.,(log(0.18)/log(2)))} {MID_PT.y} {MID_PT.z}}
  SSTSKernel_defaultMax {{pow(2.,(log(MAX_PT.x)/log(2)))} {MAX_PT.y} {MAX_PT.z}}
  SSTSKernel_coefsLow {{"(MIN_PT.z * (log10(MIN_PT.x)-0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"(MIN_PT.z * (log10(MIN_PT.x)+0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"log10(MIN_PT.y) + pctLow*(log10(MID_PT.y)-log10(MIN_PT.y))"} {"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {SSTSKernel_coefsLow.4}}
  SSTSKernel_coefsHigh {{"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"log10(MID_PT.y) + pctHigh*(log10(MAX_PT.y)-log10(MID_PT.y))"} {"(MAX_PT.z * (log10(MAX_PT.x)-0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {"(MAX_PT.z * (log10(MAX_PT.x)+0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {SSTSKernel_coefsHigh.4}}
  SSTSKernel_M1 {
      {0.5 -1 0.5}
      {-1 1 0}
      {0.5 0.5 0}
    }
  SSTSKernel_inverse {{direction}}
  rebuild_finalise ""
  name SSTS_Blink2
  note_font "Bitstream Vera Sans"
  xpos -1343
  ypos -352
  addUserKnob {20 User}
  addUserKnob {13 luminances}
  luminances {{parent.ssts_luminance.0} {parent.ssts_luminance.1} {parent.ssts_luminance.2}}
  addUserKnob {4 direction M {forward inverse}}
  addUserKnob {20 SSTSParams}
  addUserKnob {13 MIN_PT}
  MIN_PT {{0.18*pow(2,minTable(log10(luminances.x)))} {luminances.x} 0}
  addUserKnob {13 MID_PT}
  MID_PT {0.18 4.8 1.55}
  addUserKnob {13 MAX_PT}
  MAX_PT {{0.18*pow(2,maxTable(log10(luminances.z)))} {luminances.z} 0}
  addUserKnob {7 knotIncLow}
  knotIncLow {{"(log10(MID_PT.x) - log10(MIN_PT.x)) / 3"}}
  addUserKnob {7 knotIncHigh}
  knotIncHigh {{"(log10(MAX_PT.x) - log10(MID_PT.x)) / 3"}}
  addUserKnob {7 pctLow}
  pctLow {{bendsLow(log(MIN_PT.x/0.18)/log(2))}}
  addUserKnob {7 pctHigh}
  pctHigh {{bendsHigh(log(MAX_PT.x/0.18)/log(2))}}
  addUserKnob {20 Tables}
  addUserKnob {7 minTable}
  minTable {{curve L l x-4 -15 x-1.69896996 -6.5}}
  addUserKnob {7 maxTable}
  maxTable {{curve L l x1.681241274 6.5 x4 18}}
  addUserKnob {7 bendsLow}
  bendsLow {{curve L l x-15 0.18 x-6.5 0.35}}
  addUserKnob {7 bendsHigh}
  bendsHigh {{curve l x6.5 0.89 x18 0.9}}
  addUserKnob {20 Constants}
  addUserKnob {7 MIN_STOP_SDR R -10 10}
  MIN_STOP_SDR -6.5
  addUserKnob {7 MAX_STOP_SDR R -10 10}
  MAX_STOP_SDR 6.5
  addUserKnob {7 MIN_STOP_RRT R -20 20}
  MIN_STOP_RRT -15
  addUserKnob {7 MAX_STOP_RRT R -20 20}
  MAX_STOP_RRT 18
  addUserKnob {7 MIN_LUM_SDR}
  MIN_LUM_SDR 0.02
  addUserKnob {7 MAX_LUM_SDR R 0 200}
  MAX_LUM_SDR 48
  addUserKnob {7 MIN_LUM_RRT}
  MIN_LUM_RRT 0.0001
  addUserKnob {7 MAX_LUM_RRT R 0 10000}
  MAX_LUM_RRT 10000
  addUserKnob {3 N_KNOTS_LOW}
  N_KNOTS_LOW 4
  addUserKnob {3 N_KNOTS_HIGH}
  N_KNOTS_HIGH 4
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply12
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos -1343
  ypos -316
 }
 Group {
  name st2048_4
  label "Lum to PQ (ZCAM)"
  xpos -1343
  ypos -268
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1b63d7e0 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1b63d7e0
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Dot {
  name Dot40
  note_font "Bitstream Vera Sans"
  xpos -1309
  ypos -226
 }
set N1b67ab10 [stack 0]
 Dot {
  name Dot6
  note_font "Bitstream Vera Sans"
  xpos -1452
  ypos -226
 }
 Dot {
  name Dot10
  note_font "Bitstream Vera Sans"
  xpos -1452
  ypos -318
 }
 Expression {
  temp_name0 HALF_MIN
  temp_expr0 0.0000000596046448
  expr0 log10(max(HALF_MIN,r))
  channel1 none
  channel2 none
  channel3 none
  name Expression2
  label log10
  note_font "Bitstream Vera Sans"
  xpos -1544
  ypos -327
 }
 Merge2 {
  inputs 2
  operation minus
  name Merge3
  label "diff tonescale"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -327
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge6
  label "remove toe"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -291
 }
 Multiply {
  channels rgb
  value {{parent.desatHighlights}}
  name Multiply4
  label "desat scale"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -255
 }
 Group {
  name SoftclipExpression2
  label "avoid negative values for M"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -219
  addUserKnob {20 User}
  addUserKnob {18 clip_to}
  clip_to 0.9
  addUserKnob {6 clip_to_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 clip_to_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 clip_to_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 threshold}
  threshold 0.8
  addUserKnob {6 threshold_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {4 direction M {forward inverse}}
  addUserKnob {7 mix}
  mix 1
 }
  Input {
   inputs 0
   name Input1
   xpos -284
   ypos 135
  }
  Multiply {
   value {{1/parent.clip_to.r} {1/parent.clip_to.g} {1/parent.clip_to.b} 1}
   name Multiply1
   note_font "Bitstream Vera Sans"
   xpos -284
   ypos 159
  }
set N1b6c9ce0 [stack 0]
  Expression {
   temp_name0 one_minus_e
   temp_expr0 "1 - pow(10,-15)"
   temp_name1 maxr
   temp_expr1 "(pow(threshold.r, 2) - 2 * threshold.r * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   temp_name2 maxg
   temp_expr2 "(pow(threshold.g, 2) - 2 * threshold.g * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   temp_name3 maxb
   temp_expr3 "(pow(threshold.b, 2) - 2 * threshold.b * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   expr0 " threshold.r < 1 ? r >= 1 ? maxr : r > threshold.r ? (pow(threshold.r, 2) - 2 * threshold.r * r + r ) / ( 1 - r ) : r : r"
   expr1 " threshold.g < 1 ? g >= 1 ? maxg : g > threshold.g ? (pow(threshold.g, 2) - 2 * threshold.g * g + g ) / ( 1 - g ) : g : g"
   expr2 " threshold.b < 1 ? b >= 1 ? maxb : b > threshold.b ? (pow(threshold.b, 2) - 2 * threshold.b * b + b ) / ( 1 - b ) : b : b"
   expr3 a
   mix {{parent.mix}}
   name Expression2
   label inverse
   xpos -222
   ypos 257
   addUserKnob {20 User}
   addUserKnob {18 threshold}
   threshold {{parent.threshold.r} {parent.threshold.g} {parent.threshold.b}}
   addUserKnob {6 threshold_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  }
push $N1b6c9ce0
  Expression {
   expr0 "threshold.r < 1 ? r > threshold.r ? ( -1 / (( r - threshold.r ) / ( 1 - threshold.r ) +1 ) +1 ) * ( 1 - threshold.r ) + threshold.r : r : r"
   expr1 "threshold.g < 1 ? g > threshold.g ? ( -1 / (( g - threshold.g ) / ( 1 - threshold.g ) +1 ) +1 ) * ( 1 - threshold.g ) + threshold.g : g : g"
   expr2 "threshold.b < 1 ? b > threshold.b ? ( -1 / (( b - threshold.b ) / ( 1 - threshold.b ) +1 ) +1 ) * ( 1 - threshold.b ) + threshold.b : b : b"
   expr3 a
   mix {{parent.mix}}
   name Expression1
   label forward
   xpos -349
   ypos 258
   addUserKnob {20 User}
   addUserKnob {18 threshold_1 l threshold}
   threshold_1 {{parent.threshold.r} {parent.threshold.g} {parent.threshold.b}}
   addUserKnob {6 threshold_1_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   note_font "Bitstream Vera Sans"
   xpos -287
   ypos 356
  }
  Multiply {
   value {{parent.clip_to.r} {parent.clip_to.g} {parent.clip_to.b} 1}
   name Multiply2
   note_font "Bitstream Vera Sans"
   xpos -287
   ypos 380
  }
  Output {
   name Output1
   xpos -287
   ypos 463
  }
 end_group
 Clamp {
  channels rgb
  name Clamp2
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -183
 }
 Invert {
  channels rgb
  name Invert1
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -159
 }
 Shuffle {
  red white
  green red
  blue white
  alpha white
  name Shuffle2
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -135
 }
push $N1b67ab10
push $N1b461410
 Dot {
  name Dot13
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos -226
 }
set N1b7405f0 [stack 0]
 Switch {
  inputs 2
  which {{parent.applySSTS}}
  name Switch2
  label "apply SSTS"
  note_font "Bitstream Vera Sans"
  xpos -1258
  ypos -235
 }
 Group {
  name Group1
  label "Re-Generate J\nfrom Iz"
  xpos -1258
  ypos -168
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{ZCAM_IzMh_Blink1.referenceWhite}}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 10000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{ZCAM_IzMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 200}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {20 Factors}
  addUserKnob {7 F}
  F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
  addUserKnob {7 F_s}
  F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
  addUserKnob {7 L_A}
  L_A {{"referenceLuminance * backgroundLuminance / 100"}}
  addUserKnob {7 F_b}
  F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
  addUserKnob {7 F_L}
  F_L {{"0.171*pow(L_A, 1/3) * (1-exp(-48/9*L_A))"}}
 }
  BackdropNode {
   inputs 0
   name BackdropNode7
   tile_color 0x666666ff
   label "Reference White"
   note_font_size 20
   xpos 27
   ypos -149
   bdwidth 177
   bdheight 144
  }
  Input {
   inputs 0
   name Input
   xpos -66
   ypos -264
  }
  Dot {
   name Dot1
   xpos -32
   ypos -184
  }
set N1b7648b0 [stack 0]
  Dot {
   name Dot11
   xpos 114
   ypos -184
  }
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 80
   ypos -112
  }
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name Colorspace2
   xpos 80
   ypos -76
  }
  Expression {
   temp_name0 gain
   temp_expr0 parent.referenceLuminance/g
   expr0 r*gain
   expr1 g*gain
   expr2 b*gain
   name Expression0
   xpos 80
   ypos -50
  }
  Group {
   name XYZ_w_to_Izazbz
   xpos 80
   ypos -26
  }
   Input {
    inputs 0
    name Input1
    xpos 148
    ypos 197
   }
   Expression {
    temp_name0 cb
    temp_expr0 1.15
    temp_name1 cg
    temp_expr1 0.66
    expr0 "(cb*r) - ((cb-1)*b)"
    expr1 "(cg*g) - ((cg-1)*r)"
    expr2 b
    name Expression1
    label "XYZ (D65)\nto\nX'Y'Z (D65)"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 237
   }
   ColorMatrix {
    matrix {
        {0.41478972 0.579999 0.014648}
        {-0.20151 1.120649 0.0531008}
        {-0.0166008 0.2648 0.6684799}
      }
    name ColorMatrix1
    label "X'Y'Z (D65)\nto\nLMS"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 297
   }
   Expression {
    temp_name0 c1
    temp_expr0 "3424 / pow(2,12)"
    temp_name1 c2
    temp_expr1 "2413 / pow(2,7)"
    temp_name2 c3
    temp_expr2 "2392 / pow(2,7)"
    temp_name3 n
    temp_expr3 2610/pow(2,14)
    expr0 "pow( ( c1 + c2 * pow((r/10000),n) ) / ( 1 + c3 * pow((r/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    expr1 "pow( ( c1 + c2 * pow((g/10000),n) ) / ( 1 + c3 * pow((g/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    expr2 "pow( ( c1 + c2 * pow((b/10000),n) ) / ( 1 + c3 * pow((b/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    name Expression2
    label "LMS\nto\nL'M'S'"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 357
   }
   ColorMatrix {
    matrix {
        {0 {1-epsilon} 0}
        {3.524 -4.066708 0.542708}
        {0.199076 1.096799 -1.295875}
      }
    name ColorMatrix2
    label "L'M'S\nto\nIzazbz"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 417
    addUserKnob {20 User}
    addUserKnob {7 epsilon}
    epsilon 3.703522621e-11
   }
   Output {
    name Output1
    xpos 148
    ypos 517
   }
  end_group
  Dot {
   name Dot2
   xpos 114
   ypos 53
  }
push $N1b7648b0
add_layer {zcam_1d zcam_1d.J zcam_1d.C zcam_1d.h zcam_1d.Q zcam_1d.M zcam_1d.H}
  MergeExpression {
   inputs 2
   temp_name0 Qz
   temp_expr0 "2700 * pow(Br, (1.6 * parent.F_s) / pow(parent.F_b, 0.12)) * pow(parent.F_s, 2.2) * pow(parent.F_b, 0.5) * pow(parent.F_L, 0.2)"
   temp_name1 Qzw
   temp_expr1 "2700 * pow(Ar, (1.6 * parent.F_s) / pow(parent.F_b, 0.12)) * pow(parent.F_s, 2.2) * pow(parent.F_b, 0.5) * pow(parent.F_L, 0.2)"
   temp_name2 j
   temp_expr2 100*(Qz/Qzw)
   channel0 {zcam_1d.J -zcam_1d.C -zcam_1d.h none}
   expr0 j
   channel1 {rgba.red -rgba.green -rgba.blue none}
   expr1 j
   channel2 none
   channel3 none
   name MergeExpression1
   xpos -66
   ypos 50
  }
  Output {
   name Output
   xpos -66
   ypos 117
  }
 end_group
push $N1b7405f0
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy1
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos -159
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge4
  label "highlight de-sat"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos -135
  disable {{!parent.applyHighlightDesat}}
 }
 Dot {
  name Dot1
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos -23
 }
set N1b8262f0 [stack 0]
 Dot {
  name Dot31
  note_font "Bitstream Vera Sans"
  xpos -1004
  ypos -23
 }
set N1b82b020 [stack 0]
 Dot {
  name Dot28
  note_font "Bitstream Vera Sans"
  xpos -854
  ypos -23
 }
set N1b82ff10 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle1
  label "Clear to White"
  note_font "Bitstream Vera Sans"
  xpos -736
  ypos -32
 }
 Colorspace {
  illuminant_in {{parent.illuminant_out}}
  primary_in {{parent.primary_out}}
  colorspace_out CIE-XYZ
  name Colorspace5
  label "Output White to XYZ"
  xpos -736
  ypos 4
 }
 Multiply {
  channels rgb
  value {{parent.ssts_luminance.1}}
  name Multiply22
  label "scale to SSTS\nmid luminance"
  note_font "Bitstream Vera Sans"
  xpos -736
  ypos 36
 }
 Group {
  name ZCAM_JMh_Blink2
  label "XYZ to JMh\nno drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -736
  ypos 84
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.white}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1b87ffd0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1b884f90 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1b884f90
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1b87ffd0
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
push $N1b82ff10
 Group {
  name ZCAM_GamutBoundaryBlink1
  note_font "Bitstream Vera Sans"
  xpos -888
  ypos 10
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionJ}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
  outputCusps true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1b944360 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1b9492b0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1b9492b0
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1b944360
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
 Dot {
  name Dot32
  note_font "Bitstream Vera Sans"
  xpos -854
  ypos 135
 }
set N1b9a09b0 [stack 0]
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy7
  note_font "Bitstream Vera Sans"
  xpos -736
  ypos 132
 }
 Dot {
  name Dot18
  note_font "Bitstream Vera Sans"
  xpos -702
  ypos 188
 }
push $N1b9a09b0
 Switch {
  inputs 2
  which {{parent.focusTarget}}
  name Switch6
  label "Cusp or SSTSmid"
  note_font "Bitstream Vera Sans"
  xpos -888
  ypos 179
 }
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply6
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -888
  ypos 215
 }
push $N1b82b020
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply2
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -1038
  ypos 173
 }
 MergeExpression {
  inputs 2
  temp_name0 v
  temp_expr0 Bg/Ab
  temp_name1 relThreshold
  temp_expr1 max(0,threshold*Ag/Ab)
  temp_name2 s
  temp_expr2 (limit-relThreshold)/pow(pow((1-relThreshold)/(limit-relThreshold),-power)-1,1/power)
  temp_name3 compressed
  temp_expr3 (v<relThreshold||limit<1.0001)?v:relThreshold+s*((v-relThreshold)/s)/(pow(1+pow((v-relThreshold)/s,power),1/power))
  expr0 (Br-Ar*cuspFocus)*(compressed/v)+Ar*cuspFocus
  name MergeExpression2
  label "Compress to Cusp"
  note_font "Bitstream Vera Sans"
  xpos -1038
  ypos 221
  addUserKnob {20 User}
  addUserKnob {7 threshold}
  threshold {{parent.compressionJ.0}}
  addUserKnob {7 limit R 1 10}
  limit {{parent.compressionJ.1}}
  addUserKnob {7 power R 0 3}
  power {{parent.compressionJ.2}}
  addUserKnob {7 cuspFocus R 0 2}
  cuspFocus {{parent.focusScale}}
 }
 Multiply {
  channels rgb
  value {{parent.reference_luminance} 1 1 1}
  name Multiply8
  label "De-Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -1038
  ypos 257
 }
push $N1b8262f0
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy5
  label "Apply Modified\nLightness (J)"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 257
  disable {{!parent.applyGamutMappingJ}}
 }
 Dot {
  name Dot33
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos 385
 }
set N1ba27380 [stack 0]
 Dot {
  name Dot2
  note_font "Bitstream Vera Sans"
  xpos -994
  ypos 385
 }
set N1ba2c250 [stack 0]
 Dot {
  name Dot23
  note_font "Bitstream Vera Sans"
  xpos -850
  ypos 385
 }
 Group {
  name ZCAM_GamutBoundaryBlink3
  note_font "Bitstream Vera Sans"
  xpos -884
  ypos 457
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionM}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   illuminant_out {{parent.parent.white}}
   primary_out {{parent.parent.gamut}}
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1ba7c180 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1ba810c0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1ba810c0
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1ba7c180
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
set N1ba36040 [stack 0]
 Dot {
  name Dot4
  note_font "Bitstream Vera Sans"
  xpos -850
  ypos 525
 }
push $N1ba2c250
push $N1ba36040
 Merge2 {
  inputs 2
  operation divide
  name Merge1
  xpos -1028
  ypos 457
 }
 Expression {
  expr0 (r<thr.r||lim.r<1.0001)?r:thr.r+s.r*((r-thr.r)/s.r)/(pow(1+pow((r-thr.r)/s.r,p),1/p))
  expr1 (g<thr.g||lim.g<1.0001)?g:thr.g+s.g*((g-thr.g)/s.g)/(pow(1+pow((g-thr.g)/s.g,p),1/p))
  expr2 (b<thr.b||lim.b<1.0001)?b:thr.b+s.b*((b-thr.b)/s.b)/(pow(1+pow((b-thr.b)/s.b,p),1/p))
  name Compress
  label Power(P)
  xpos -1028
  ypos 481
  addUserKnob {20 Params_tab l Params}
  addUserKnob {18 thr}
  thr {{parent.compressionM.0}}
  addUserKnob {6 thr_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 lim}
  lim {{parent.compressionM.1}}
  addUserKnob {6 lim_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 s}
  s {{(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)} {(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)} {(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)}}
  addUserKnob {6 s_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {7 p R 1 5}
  p {{parent.compressionM.2}}
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge2
  xpos -1028
  ypos 522
 }
push $N1ba27380
 ShuffleCopy {
  inputs 2
  green green
  alpha alpha2
  name ShuffleCopy2
  label "Apply Compressed\nColourfulness (M)"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 510
  disable {{!parent.applyGamutMappingM}}
 }
 Group {
  name ZCAM_JMh_Blink1
  label "JMh to XYZ"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 714
  addUserKnob {20 User}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {4 catType l "CAT Type" M {None "XYZ Scaling" Bradford CAT02 Zhai2018 ""}}
  catType Zhai2018
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1bb55720 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1bb5a640 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1bb5a640
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1bb55720
  BlinkScript {
   inputs 3
   recompileCount 67
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise b4a2d45f8223b30a707c942561ca9c894db336576c95ad6a60c024522a2e900c 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
   addUserKnob {20 User}
   addUserKnob {7 epsilon}
   epsilon 3.703522621e-11
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Multiply {
  channels rgb
  value {{1/parent.ssts_luminance.2}}
  name Multiply5
  label "Lum to Linear"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 750
  disable {{Colorspace3.colorspace_out==31}}
 }
 Colorspace {
  colorspace_in CIE-XYZ
  colorspace_out BT1886
  name Colorspace3
  label "XYZ to Output"
  xpos -1148
  ypos 786
 }
 Clamp {
  channels rgb
  name Clamp6
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 818
  disable {{!parent.clamp_output}}
 }
 Dot {
  name Dot26
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos 909
 }
 Dot {
  name Dot27
  note_font "Bitstream Vera Sans"
  xpos -502
  ypos 909
 }
 Switch {
  inputs 2
  which {{parent.invert}}
  name Switch1
  note_font "Bitstream Vera Sans"
  xpos -516
  ypos 948
 }
 Output {
  name Output
  xpos -516
  ypos 1074
 }
end_group
Group {
 name Plot_ZCAM_JMh_Boundary1
 note_font "Bitstream Vera Sans"
 xpos -2177
 ypos -445
 addUserKnob {20 User}
 addUserKnob {26 input_settings_divider l "Input Settings"}
 addUserKnob {41 colorspace_in l colorspace T Colorspace3.colorspace_in}
 addUserKnob {41 illuminant_in l "" -STARTLINE T Colorspace3.illuminant_in}
 addUserKnob {41 primary_in l "" -STARTLINE T Colorspace3.primary_in}
 addUserKnob {7 inputReferenceLuminance l referenceLuminance R 0 10000}
 inputReferenceLuminance 100
 addUserKnob {26 zcam_settings_divider l "ZCAM Settings"}
 addUserKnob {41 referenceWhite T ZCAM_JMh_Blink1.referenceWhite}
 addUserKnob {41 referenceLuminance -STARTLINE T ZCAM_JMh_Blink1.referenceLuminance}
 addUserKnob {41 viewingConditions T ZCAM_JMh_Blink1.viewingConditions}
 addUserKnob {41 backgroundLuminance -STARTLINE T ZCAM_JMh_Blink1.backgroundLuminance}
 addUserKnob {41 catType l "CAT Type" T ZCAM_JMh_Blink1.catType}
 addUserKnob {41 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE T ZCAM_JMh_Blink1.discountIlluminant}
 addUserKnob {26 boundary_settings_divider l "Boundary Settings"}
 addUserKnob {41 illuminant l "boundary illuminant" T Colorspace1.illuminant_out}
 addUserKnob {41 primary -STARTLINE T Colorspace1.primary_out}
 addUserKnob {7 boundaryLuminance l luminance -STARTLINE R 0 1000}
 boundaryLuminance 100
 addUserKnob {7 hue R 0 360}
 hue 330
 addUserKnob {7 hueTolerance -STARTLINE R 0 60}
 hueTolerance 2
 addUserKnob {26 plot_settings_divider l "Plot Settings"}
 addUserKnob {7 MRange l "M Range" R 0 100}
 MRange 80
 addUserKnob {7 luminanceRange R 0 1000}
 luminanceRange 100
 addUserKnob {7 size R 0 10}
 size 1
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  label "Plot Input Samples"
  note_font_size 20
  xpos -278
  ypos -419
  bdwidth 658
  bdheight 596
 }
 Constant {
  inputs 0
  format "1024 1024 0 0 1024 1024 1 square_1k"
  name Constant1
  xpos -908
  ypos -266
 }
 Dot {
  name Dot3
  note_font "Bitstream Vera Sans"
  xpos -874
  ypos -179
 }
set N1bc333f0 [stack 0]
 Dot {
  name Dot4
  note_font "Bitstream Vera Sans"
  xpos -1069
  ypos -179
 }
 Shuffle {
  red white
  green white
  blue white
  alpha white
  name Shuffle4
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1103
  ypos -104
 }
 Multiply {
  channels rgb
  value {{parent.luminanceRange}}
  name Multiply8
  note_font "Bitstream Vera Sans"
  xpos -1103
  ypos -68
 }
 Group {
  name ZCAM_JMh_Blink5
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -1103
  ypos -37
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.referenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1bc6fe50 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1bc74d70 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1bc74d70
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1bc6fe50
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Shuffle {
  green white
  blue white
  alpha white
  name Shuffle5
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1103
  ypos 2
 }
push $N1bc333f0
 Expression {
  temp_name0 vx
  temp_expr0 x/(input.width-1)
  temp_name1 vy
  temp_expr1 y/(input.height-1)
  expr0 vy
  expr1 vx
  expr2 1
  expr3 0
  name Expression1
  label "Generate Ramps"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -147
 }
 Multiply {
  channels rgb
  value {1 {parent.MRange} {parent.hue} 1}
  name Multiply1
  label "Scale M & h"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -49
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge4
  label "scale J"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 2
 }
 Dot {
  name Dot2
  note_font "Bitstream Vera Sans"
  xpos -874
  ypos 54
 }
set N1bd24190 [stack 0]
 Group {
  name ZCAM_JMh_Blink6
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 87
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.referenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1bd3f000 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1bd43f20 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1bd43f20
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1bd3f000
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Multiply {
  channels rgb
  value {{1/parent.boundaryLuminance}}
  name Multiply2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 132
 }
 Colorspace {
  colorspace_in CIE-XYZ
  name Colorspace1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 188
 }
 Expression {
  temp_expr0 parent.size
  temp_name1 inr
  temp_expr1 "r <= 0 ? 0 : r > 1 ? 0 : 1"
  temp_name2 ing
  temp_expr2 "g <=0 ? 0 : g > 1 ? 0 : 1"
  temp_name3 inb
  temp_expr3 "b <= 0 ? 0 : b > 1 ? 0 : 1"
  expr3 "inr * ing * inb"
  name Expression2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 240
 }
set N1bddbb20 [stack 0]
 EdgeDetectWrapper {
  edgedetector simple
  channels alpha
  erodesize {{-parent.size}}
  blurquality 0
  name EdgeDetect1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 659
 }
push $N1bddbb20
push $N1bd24190
 Dot {
  name Dot1
  note_font "Bitstream Vera Sans"
  xpos -674
  ypos 54
 }
 ShuffleCopy {
  inputs 2
  name ShuffleCopy1
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 240
 }
 Premult {
  channels {rgba.red rgba.green -rgba.blue none}
  name Premult1
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 283
 }
set N1be0df50 [stack 0]
 Dilate {
  size {0 {input.height*2}}
  name Dilate3
  note_font "Bitstream Vera Sans"
  xpos -488
  ypos 277
 }
 Expression {
  expr0 r*g
  name Expression3
  note_font "Bitstream Vera Sans"
  xpos -488
  ypos 363
 }
push $N1be0df50
 Dilate {
  channels {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  size {{input.width*2} 0}
  name Dilate1
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 319
 }
 Dilate {
  channels {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  size {0 {input.height*2}}
  name Dilate2
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 403
 }
set N1be3b570 [stack 0]
 Shuffle {
  red green
  blue green
  name Shuffle1
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -598
  ypos 397
 }
 Merge2 {
  inputs 2
  operation divide
  name Merge1
  note_font "Bitstream Vera Sans"
  xpos -488
  ypos 403
 }
 Dilate {
  size {{input.width*2} 0}
  name Dilate5
  note_font "Bitstream Vera Sans"
  xpos -488
  ypos 443
 }
push $N1be3b570
 ShuffleCopy {
  inputs 2
  red red
  name ShuffleCopy2
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 449
 }
 Reformat {
  type "to box"
  box_width 2
  box_height 2
  resize none
  filter Impulse
  name Reformat1
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 506
 }
 Group {
  name ZCAM_JMh_Blink4
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 530
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.referenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1bea9500 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1beae420 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1beae420
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1bea9500
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Reformat {
  type "to box"
  box_width {{input.input.input.width}}
  box_height {{input.input.input.height}}
  box_fixed true
  resize distort
  filter Impulse
  name Reformat2
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 566
 }
 Multiply {
  value {{1/parent.boundaryLuminance}}
  name Multiply3
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 654
 }
 Colorspace {
  colorspace_in CIE-XYZ
  name Colorspace2
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 708
 }
 ShuffleCopy {
  inputs 2
  name ShuffleCopy3
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 708
 }
 Premult {
  name Premult2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 774
 }
 Input {
  inputs 0
  name Input
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -301
 }
 Colorspace {
  colorspace_in BT1886
  colorspace_out CIE-XYZ
  name Colorspace3
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -220
 }
set N1bf73460 [stack 0]
 Multiply {
  channels rgb
  value {{parent.inputReferenceLuminance}}
  name Multiply5
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -194
  disable {{Colorspace3.colorspace_in==31}}
 }
 Group {
  name ZCAM_JMh_Blink1
  note_font "Bitstream Vera Sans"
  selected true
  xpos 4
  ypos -145
  addUserKnob {20 User}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance 100
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance 10
  addUserKnob {4 catType l "CAT Type" M {None "XYZ Scaling" Bradford CAT02 Zhai2018}}
  catType Zhai2018
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1bfad750 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1bfb2670 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1bfb2670
  Colorspace {
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1bfad750
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   selected true
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Expression {
  temp_name0 hue
  temp_expr0 b
  temp_name1 hueSlice
  temp_expr1 "(parent.hue < 0 ? parent.hue + 360 * ceil(abs(parent.hue)/360) : parent.hue)%360"
  temp_name2 visible
  temp_expr2 "hue >= hueSlice-parent.hueTolerance ? hue <=  hueSlice+parent.hueTolerance ? 1 : hue-360 >  hueSlice-parent.hueTolerance ? 1 : 0  : 0"
  expr0 r
  expr1 "visible ? g : 0"
  expr2 "visible ? r : 0"
  channel3 alpha
  expr3 visible
  name Expression4
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -90
 }
set N1c025ba0 [stack 0]
 Multiply {
  channels rgb
  value {1 {1/parent.MRange} 1 1}
  name Multiply4
  label "scale M"
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -14
 }
push $N1c025ba0
 Shuffle {
  red white
  green white
  blue white
  alpha white
  name Shuffle2
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -189
  ypos -96
 }
 Multiply {
  channels rgb
  value {{parent.luminanceRange}}
  name Multiply6
  note_font "Bitstream Vera Sans"
  xpos -189
  ypos -60
 }
 Group {
  name ZCAM_JMh_Blink3
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -189
  ypos -29
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.referenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1c073010 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1c077f30 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1c077f30
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1c073010
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Shuffle {
  red white
  green white
  blue red
  alpha white
  name Shuffle3
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -189
  ypos 22
 }
 Merge2 {
  inputs 2
  operation divide
  name Merge3
  label "scale J"
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos 22
 }
push $N1c025ba0
push $N1bf73460
 Colorspace {
  colorspace_in CIE-XYZ
  colorspace_out BT1886
  name Colorspace4
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos -220
 }
 Multiply {
  value {{1-Add3.value}}
  name Multiply7
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos -162
 }
 Add {
  value 0.1
  name Add3
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos -126
 }
 ShuffleCopy {
  inputs 2
  name ShuffleCopy4
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos -90
 }
 Premult {
  name Premult3
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos 77
 }
 BlinkScript {
  inputs 2
  recompileCount 4
  ProgramGroup 1
  KernelDescription "2 \"plot_cie_xy\" iterate pixelWise 4f09b488f640fe57a9b92d835cc81424078e447e427d9f43fb8d958e7333c795 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 4 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"bottom_margin\" Float 1 AAAAAA== \"process_input\" Bool 1 AA== 4 \"padding\" 1 1 \"left_margin\" 1 1 \"bottom_margin\" 1 1 \"process_input\" 1 1 3 \"outsize\" Float 1 1 AAAAAA== \"offsetX\" Float 1 1 AAAAAA== \"offsetY\" Float 1 1 AAAAAA=="
  kernelSource "kernel plot_cie_xy : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float bottom_margin;\n  bool process_input;\n\n\nlocal:\n  float outsize;\n  float offsetX;\n  float offsetY;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = dst.bounds.height()/padding;\n    // xy offset for margin on lower left corner\n    offsetX = left_margin;\n    offsetY = bottom_margin;\n  \}\n\n  void process(int2 pos) \{\n    // All the work will be done in the first pixel of the iteration. Essentially a single thread.\n    if ( pos.x > 1 || pos.y > 1) \{ return; \}\n    // Loop over all pixels in input Yxy\n    if (process_input) \{\n      for ( int j = Yxy.bounds.y1; j < Yxy.bounds.y2; j++) \{\n        for ( int i = Yxy.bounds.x1; i < Yxy.bounds.x2; i++) \{\n          // sample Yxy pixel at position i, j\n          float2 xy = float2(Yxy(i, j, 1), Yxy(i, j, 2));\n          // don't process black pixels\n          if( xy.x == 0.0f && xy.y == 0.0f) \{ continue; \}\n          // calculate output position: xy chromaticity coordinates at centered output pixel position\n          float2 out_pos = float2(xy.x * outsize + offsetX, xy.y * outsize + offsetY);\n          // Write color value to xy sample position in dst\n          if ( dst.bounds.inside(out_pos.x, out_pos.y)) \{ dst(out_pos.x, out_pos.y) = col(i, j); \}\n        \}\n      \}\n    \}\n  \}\n\};"
  vectorize false
  rebuild ""
  plot_cie_xy_padding 1
  plot_cie_xy_process_input true
  format "1024 1024 0 0 1024 1024 1 square_1k"
  specifiedFormat true
  rebuild_finalise ""
  name Plot_Input1
  xpos 4
  ypos 73
  cached true
 }
 Dilate {
  size {{parent.size}}
  name Dilate4
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos 123
 }
 Dot {
  name Dot5
  note_font "Bitstream Vera Sans"
  xpos 52
  ypos 818
 }
 Merge2 {
  inputs 2
  name Merge2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 815
 }
 Output {
  name Output1
  xpos -908
  ypos 857
 }
end_group
Group {
 inputs 0
 name GeneratGridZCAM2
 note_font "Bitstream Vera Sans"
 xpos -1911
 ypos -584
 addUserKnob {20 User}
 addUserKnob {26 zcam_settings_divider l "ZCAM Settings"}
 addUserKnob {41 referenceWhite T ZCAM_JMh_Blink2.referenceWhite}
 addUserKnob {41 zcamReferenceLuminance l referenceLuminance -STARTLINE T ZCAM_JMh_Blink2.referenceLuminance}
 addUserKnob {41 viewingConditions T ZCAM_JMh_Blink2.viewingConditions}
 addUserKnob {41 backgroundLuminance -STARTLINE T ZCAM_JMh_Blink2.backgroundLuminance}
 addUserKnob {41 catType l "CAT Type" T ZCAM_JMh_Blink2.catType}
 addUserKnob {41 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE T ZCAM_JMh_Blink2.discountIlluminant}
 addUserKnob {26 grid_setting_divider l "Grid Settings"}
 addUserKnob {7 hueSlice l "hue slice" R 0 360}
 hueSlice {{Plot_ZCAM_JMh_Boundary2.hue}}
 addUserKnob {7 MRange l "M range" R 0 100}
 MRange 80
 addUserKnob {7 luminanceRange l "luminance range" R 0 1000}
 luminanceRange 10000
 addUserKnob {26 output_settings_divider l "Output Settings"}
 addUserKnob {41 colorspace_out l colorspace T Colorspace1.colorspace_out}
 addUserKnob {41 illuminant_out l "" -STARTLINE T Colorspace1.illuminant_out}
 addUserKnob {41 primary_out l "" -STARTLINE T Colorspace1.primary_out}
 addUserKnob {7 outputReferenceLuminance l referenceLuminance R 0 10000}
 outputReferenceLuminance 100
}
 Constant {
  inputs 0
  format "1024 1024 0 0 1024 1024 1 square_1k"
  name Constant6
  xpos -908
  ypos -278
 }
 Reformat {
  type "to box"
  box_width 512
  box_height 16
  box_fixed true
  resize none
  name Reformat1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -206
 }
set N18c76a70 [stack 0]
 Reformat {
  type scale
  box_width 512
  box_height 16
  box_fixed true
  resize none
  turn true
  name Reformat6
  note_font "Bitstream Vera Sans"
  xpos -798
  ypos -206
 }
 Expression {
  temp_name0 vx
  temp_expr0 x/(input.width-1)
  temp_name1 vy
  temp_expr1 y/(input.height-1)
  expr0 vy
  expr1 vx
  expr2 1
  expr3 0
  name Expression7
  label "Generate Ramps"
  note_font "Bitstream Vera Sans"
  xpos -798
  ypos -182
 }
 Reformat {
  type scale
  box_width 512
  box_height 16
  box_fixed true
  resize none
  flip true
  flop true
  turn true
  black_outside true
  pbb true
  name Reformat7
  note_font "Bitstream Vera Sans"
  xpos -798
  ypos -146
 }
push $N18c76a70
 Expression {
  temp_name0 vx
  temp_expr0 x/(input.width-1)
  temp_name1 vy
  temp_expr1 y/(input.height-1)
  expr0 vy
  expr1 vx
  expr2 1
  expr3 0
  name Expression8
  label "Generate Ramps"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -182
 }
 ContactSheet {
  inputs 2
  width {{input.width}}
  height {{input.height*2}}
  rows 2
  columns 1
  name ContactSheet6
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -146
 }
set N18cc1040 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  alpha white
  name Shuffle1
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1093
  ypos -152
 }
 Multiply {
  channels rgb
  value {{parent.luminanceRange}}
  name Multiply1
  note_font "Bitstream Vera Sans"
  xpos -1093
  ypos -116
 }
 Group {
  name ZCAM_JMh_Blink1
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  selected true
  xpos -1093
  ypos -82
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.zcamReferenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N18cffae0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N18d04a00 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N18d04a00
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N18cffae0
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Shuffle {
  green white
  blue white
  alpha white
  name Shuffle2
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1093
  ypos -37
 }
push $N18cc1040
 Multiply {
  channels rgb
  value {1 {parent.MRange} {parent.hueSlice} 1}
  name Multiply7
  label "Scale M & h"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -93
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  label "scale J"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -37
 }
 Group {
  name ZCAM_JMh_Blink2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 20
  addUserKnob {20 User}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance 100
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance 10
  addUserKnob {4 catType l "CAT Type" M {None "XYZ Scaling" Bradford CAT02 Zhai2018}}
  catType Zhai2018
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N18dbb3d0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N18dc02f0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N18dc02f0
  Colorspace {
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N18dbb3d0
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   selected true
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Multiply {
  value {{1/outputReferenceLuminance}}
  name Multiply8
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 57
  disable {{Colorspace1.colorspace_out==31}}
 }
 Colorspace {
  colorspace_in CIE-XYZ
  illuminant_out ACES
  primary_out ACES
  name Colorspace1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 121
 }
 Output {
  name Output1
  xpos -908
  ypos 221
 }
end_group
Group {
 name DRT_ZCAM_IzMh_v08_Blink2
 label "\[value ssts_luminance.2]nits/\[value gamut]\n\[value colorspace_out]/\[value illuminant_out]/\[value primary_out]\n\n"
 note_font "Bitstream Vera Sans"
 xpos -1911
 ypos -539
 addUserKnob {20 User}
 addUserKnob {26 div_input l Input}
 addUserKnob {41 colorspace_in l colorspace T Colorspace1.colorspace_in}
 addUserKnob {41 illuminant_in l "" -STARTLINE T Colorspace1.illuminant_in}
 addUserKnob {41 primary_in l "" -STARTLINE T Colorspace1.primary_in}
 addUserKnob {41 catType l "CAT Type" T ZCAM_JMh_Blink1.catType}
 addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
 addUserKnob {26 div_ssts l SSTS}
 addUserKnob {6 applySSTS l "apply SSTS" +STARTLINE}
 applySSTS true
 addUserKnob {78 ssts_luminance l luminance n 3}
 ssts_luminance {0.0001 10 1000}
 addUserKnob {26 ssts_label l "" -STARTLINE T "  min / mid / peak"}
 addUserKnob {6 applyHighlightDesat l "apply highlight de-sat" +STARTLINE}
 applyHighlightDesat true
 addUserKnob {7 desatHighlights l "de-sat highlights" R 0 10}
 desatHighlights 3.5
 addUserKnob {26 div_gamutmap l "Gamut Mapping"}
 addUserKnob {41 white T ZCAM_GamutBoundaryBlink1.boundaryWhite}
 addUserKnob {41 gamut -STARTLINE T ZCAM_GamutBoundaryBlink1.boundaryGamut}
 addUserKnob {6 applyGamutMappingJ l "apply gamut mapping (J)" +STARTLINE}
 applyGamutMappingJ true
 addUserKnob {3 precisionJ l precision -STARTLINE}
 precisionJ 8
 addUserKnob {26 precision_J_label l "" -STARTLINE T "(for gamut cusp)"}
 addUserKnob {4 focusTarget M {"Gamut Cusp" "SSTS Mid"}}
 addUserKnob {7 focusScale -STARTLINE R 0 2}
 focusScale 1
 addUserKnob {78 compressionJ l "compression (J)" n 3}
 compressionJ {0.8 1.3 1.2}
 addUserKnob {26 compression_J_label l "" -STARTLINE T " threshold / limit / power"}
 addUserKnob {6 applyGamutMappingM l "apply gamut mapping (M)" +STARTLINE}
 applyGamutMappingM true
 addUserKnob {3 precisionM l precision -STARTLINE}
 precisionM 10
 addUserKnob {26 precision_label l "" -STARTLINE T " (for gamut boundary)"}
 addUserKnob {78 compressionM l "compression (M)" n 3}
 compressionM {0.8 1.3 1.2}
 addUserKnob {26 compression_label l "" -STARTLINE T " threshold / limit / power"}
 addUserKnob {26 div_output l Output}
 addUserKnob {41 colorspace_out l colorspace T Colorspace3.colorspace_out}
 addUserKnob {41 illuminant_out l "" -STARTLINE T Colorspace3.illuminant_out}
 addUserKnob {41 primary_out l "" -STARTLINE T Colorspace3.primary_out}
 addUserKnob {41 viewingConditions T ZCAM_JMh_Blink1.viewingConditions}
 addUserKnob {78 reference_luminance l "luminance reference" -STARTLINE n 1}
 reference_luminance 100
 addUserKnob {78 background_luminance l background -STARTLINE n 1}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" +STARTLINE}
 addUserKnob {26 direction}
 addUserKnob {6 invert +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  label "Un-Compress Lightness (J) from Target Gamut Cusp or SSTS mid-point\nApproximation only because original gamut boundary value has been obfuscated by the change in J\nUsing a multi-stage inverse improves precision but is expensive"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -516
  ypos -443
  bdwidth 1259
  bdheight 457
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  label "Convert J component to linearised Iz component\nand apply inverse ACES SSTS\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -517
  ypos 26
  bdwidth 1260
  bdheight 602
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  label "IzMh (ZCAM) to Output\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -518
  ypos 639
  bdwidth 1266
  bdheight 224
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  label "Compress Colourfulness (M)\nto Target Gamut Boundary\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1363
  ypos 319
  bdwidth 798
  bdheight 282
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  label "Very handwavy attempt at basing \na highlight de-sat on tonescale\n\n(this inverse node graph is more complex than than the forward graph\nin order to support separate disabling of the SSTS)"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos 760
  ypos 21
  bdwidth 873
  bdheight 616
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  label "Compress Lightness (J)\ntowards Target Gamut Cusp\nor SSTS mid-point"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1364
  ypos -75
  bdwidth 801
  bdheight 383
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  label "Apply ACES SSTS to linearised Iz component\nand convert to J component"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1366
  ypos -703
  bdwidth 802
  bdheight 620
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  label "Input to IzMh (ZCAM)\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1366
  ypos -983
  bdwidth 799
  bdheight 269
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  label "JMh (ZCAM) to Output\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1363
  ypos 610
  bdwidth 799
  bdheight 261
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  label "Very handwavy attempt at basing \na highlight de-sat on tonescale"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -1876
  ypos -707
  bdwidth 498
  bdheight 1015
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  label "Input to JMh (ZCAM)\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -516
  ypos -985
  bdwidth 1251
  bdheight 267
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  label "Un-Compress Colourfulness (M) from Target Gamut\n"
  note_font "Bitstream Vera Sans"
  note_font_size 20
  xpos -512
  ypos -704
  bdwidth 1253
  bdheight 243
 }
 Input {
  inputs 0
  name Input
  xpos -516
  ypos -1216
 }
 Dot {
  name Dot15
  note_font "Bitstream Vera Sans"
  xpos -482
  ypos -1035
 }
set N1f56a430 [stack 0]
 Dot {
  name Dot17
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos -1035
 }
 Colorspace {
  colorspace_in {{Colorspace3.colorspace_out}}
  illuminant_in {{Colorspace3.illuminant_out}}
  primary_in {{Colorspace3.primary_out}}
  colorspace_out CIE-XYZ
  name Colorspace2
  label "XYZ to Output\ninverse"
  xpos 450
  ypos -896
 }
 Multiply {
  channels rgb
  value {{parent.ssts_luminance.2}}
  name Multiply13
  label "Lum to Linear\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos -854
  disable {{Colorspace2.colorspace_in==31}}
 }
 Group {
  name ZCAM_JMh_Blink3
  label "XYZ to JMh\nno drop-downs"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos -799
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.white}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N2213ddd0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N6b823b0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N6b823b0
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N2213ddd0
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Dot {
  name Dot19
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos -670
 }
set N6c2f080 [stack 0]
 Dot {
  name Dot20
  note_font "Bitstream Vera Sans"
  xpos 260
  ypos -670
 }
set Nc8fcd00 [stack 0]
 Dot {
  name Dot21
  note_font "Bitstream Vera Sans"
  xpos 121
  ypos -670
 }
 Group {
  name ZCAM_GamutBoundaryBlink2
  note_font "Bitstream Vera Sans"
  xpos 87
  ypos -600
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionM}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   illuminant_out {{parent.parent.white}}
   primary_out {{parent.parent.gamut}}
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1f58b180 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set Nc8db6f0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $Nc8db6f0
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1f58b180
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
set N6b97030 [stack 0]
 Dot {
  name Dot22
  note_font "Bitstream Vera Sans"
  xpos 121
  ypos -519
 }
push $Nc8fcd00
push $N6b97030
 Merge2 {
  inputs 2
  operation divide
  name Merge7
  xpos 226
  ypos -600
 }
 Expression {
  expr0 (r<thr.r||lim.r<1.0001||r>thr.r+s.r)?r:thr.r+s.r*pow(-(pow((r-thr.r)/s.r,p)/(pow((r-thr.r)/s.r,p)-1)),1/p)
  expr1 (g<thr.g||lim.g<1.0001||g>thr.g+s.g)?g:thr.g+s.g*pow(-(pow((g-thr.g)/s.g,p)/(pow((g-thr.g)/s.g,p)-1)),1/p)
  expr2 (b<thr.b||lim.b<1.0001||b>thr.b+s.b)?b:thr.b+s.b*pow(-(pow((b-thr.b)/s.b,p)/(pow((b-thr.b)/s.b,p)-1)),1/p)
  name UnCompress1
  label Power(P)
  xpos 226
  ypos -565
  addUserKnob {20 Params_tab l Params}
  addUserKnob {18 thr}
  thr {{parent.compressionM.0}}
  addUserKnob {6 thr_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 lim}
  lim {{parent.compressionM.1}}
  addUserKnob {6 lim_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 s}
  s {{(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)} {(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)} {(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)}}
  addUserKnob {6 s_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {7 p R 1 5}
  p {{parent.compressionM.2}}
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge8
  xpos 226
  ypos -522
 }
push $N6c2f080
 ShuffleCopy {
  inputs 2
  green green
  alpha alpha2
  name ShuffleCopy3
  label "Apply UnCompressed\nColourfulness (M)"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos -534
  disable {{!parent.applyGamutMappingM}}
 }
 Dot {
  name Dot3
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos -359
 }
set N25144020 [stack 0]
 Dot {
  name Dot14
  note_font "Bitstream Vera Sans"
  xpos 294
  ypos -359
 }
set N25113b20 [stack 0]
 Dot {
  name Dot24
  note_font "Bitstream Vera Sans"
  xpos -72
  ypos -359
 }
set N22358ec0 [stack 0]
 Dot {
  name Dot25
  note_font "Bitstream Vera Sans"
  xpos -163
  ypos -359
 }
set N222b5040 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle6
  label "clear to white"
  note_font "Bitstream Vera Sans"
  xpos -423
  ypos -368
 }
 Colorspace {
  illuminant_in {{parent.illuminant_out}}
  primary_in {{parent.primary_out}}
  colorspace_out CIE-XYZ
  name Colorspace6
  label "Output White to XYZ"
  xpos -423
  ypos -332
 }
 Multiply {
  channels rgb
  value {{parent.ssts_luminance.1}}
  name Multiply29
  label "scale to SSTS\nmid luminance"
  note_font "Bitstream Vera Sans"
  xpos -423
  ypos -300
 }
 Group {
  name ZCAM_JMh_Blink4
  label "XYZ to JMh\nno drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -423
  ypos -252
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.white}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N259ce780 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N34b63d00 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N34b63d00
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N259ce780
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Dot {
  name Dot60
  note_font "Bitstream Vera Sans"
  xpos -389
  ypos -199
 }
set N21f09a40 [stack 0]
 Dot {
  name Dot61
  note_font "Bitstream Vera Sans"
  xpos 42
  ypos -199
 }
 Dot {
  name Dot62
  note_font "Bitstream Vera Sans"
  xpos 42
  ypos -173
 }
push $N21f09a40
 Dot {
  name Dot47
  note_font "Bitstream Vera Sans"
  xpos -389
  ypos -173
 }
push $N222b5040
 Group {
  name ZCAM_GamutBoundaryBlink5
  note_font "Bitstream Vera Sans"
  xpos -197
  ypos -269
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionJ}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
  outputCusps true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1ec435d0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N21fe6890 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N21fe6890
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1ec435d0
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
 Dot {
  name Dot55
  note_font "Bitstream Vera Sans"
  xpos -163
  ypos -219
 }
set N21e9fe60 [stack 0]
 Dot {
  name Dot57
  note_font "Bitstream Vera Sans"
  xpos -257
  ypos -219
 }
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy8
  note_font "Bitstream Vera Sans"
  xpos -291
  ypos -176
 }
push $N21e9fe60
 Switch {
  inputs 2
  which {{parent.focusTarget}}
  name Switch7
  note_font "Bitstream Vera Sans"
  xpos -197
  ypos -176
 }
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply19
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -197
  ypos -132
 }
 Dot {
  name Dot34
  note_font "Bitstream Vera Sans"
  xpos -163
  ypos -75
 }
push $N22358ec0
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply3
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -106
  ypos -132
 }
 MergeExpression {
  inputs 2
  temp_name0 v
  temp_expr0 Bg/Ab
  temp_name1 relThreshold
  temp_expr1 max(0,threshold*Ag/Ab)
  temp_name2 s
  temp_expr2 (limit-relThreshold)/pow(pow((1-relThreshold)/(limit-relThreshold),-power)-1,1/power)
  temp_name3 compressed
  temp_expr3 (v<relThreshold||limit<1.0001)?v:relThreshold+s*((v-relThreshold)/s)/(pow(1+pow((v-relThreshold)/s,power),1/power))
  expr0 (Br-Ar*cuspFocus)*(v/compressed)+Ar*cuspFocus
  name MergeExpression1
  label "Compress to Cusp"
  note_font "Bitstream Vera Sans"
  xpos -106
  ypos -84
  addUserKnob {20 User}
  addUserKnob {7 threshold}
  threshold {{parent.compressionJ.0}}
  addUserKnob {7 limit R 1 10}
  limit {{parent.compressionJ.1}}
  addUserKnob {7 power R 0 3}
  power {{parent.compressionJ.2}}
  addUserKnob {7 cuspFocus R 0 2}
  cuspFocus {{parent.focusScale}}
 }
 Multiply {
  channels rgb
  value {{parent.reference_luminance} 1 1 1}
  name Multiply7
  label "De-Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -106
  ypos -48
 }
 Dot {
  name Dot36
  note_font "Bitstream Vera Sans"
  xpos 60
  ypos -33
 }
 Dot {
  name Dot39
  note_font "Bitstream Vera Sans"
  xpos 60
  ypos -271
 }
 Group {
  name ZCAM_GamutBoundaryBlink6
  note_font "Bitstream Vera Sans"
  xpos 170
  ypos -274
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionJ}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
  outputCusps true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N39f93fb0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N36f042b0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N36f042b0
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N39f93fb0
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
 Dot {
  name Dot58
  note_font "Bitstream Vera Sans"
  xpos 204
  ypos -231
 }
set N1f50d880 [stack 0]
 Dot {
  name Dot59
  note_font "Bitstream Vera Sans"
  xpos 110
  ypos -231
 }
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy9
  note_font "Bitstream Vera Sans"
  xpos 76
  ypos -176
 }
push $N1f50d880
 Switch {
  inputs 2
  which {{parent.focusTarget}}
  name Switch8
  note_font "Bitstream Vera Sans"
  xpos 170
  ypos -176
 }
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply20
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos 170
  ypos -151
 }
 Dot {
  name Dot12
  note_font "Bitstream Vera Sans"
  xpos 204
  ypos -94
 }
push $N25113b20
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply27
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos 260
  ypos -151
 }
 MergeExpression {
  inputs 2
  temp_name0 v
  temp_expr0 Bg/Ab
  temp_name1 relThreshold
  temp_expr1 max(0,threshold*Ag/Ab)
  temp_name2 s
  temp_expr2 (limit-relThreshold)/pow(pow((1-relThreshold)/(limit-relThreshold),-power)-1,1/power)
  temp_name3 compressed
  temp_expr3 (v<relThreshold||limit<1.0001)?v:relThreshold+s*((v-relThreshold)/s)/(pow(1+pow((v-relThreshold)/s,power),1/power))
  expr0 (Br-Ar*cuspFocus)*(v/compressed)+Ar*cuspFocus
  name MergeExpression3
  label "Compress to Cusp"
  note_font "Bitstream Vera Sans"
  xpos 260
  ypos -103
  addUserKnob {20 User}
  addUserKnob {7 threshold}
  threshold {{parent.compressionJ.0}}
  addUserKnob {7 limit R 1 10}
  limit {{parent.compressionJ.1}}
  addUserKnob {7 power R 0 3}
  power {{parent.compressionJ.2}}
  addUserKnob {7 cuspFocus R 0 2}
  cuspFocus {{parent.focusScale}}
 }
 Multiply {
  channels rgb
  value {{parent.reference_luminance} 1 1 1}
  name Multiply28
  label "De-Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos 260
  ypos -67
 }
push $N25144020
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy6
  label "Apply UnCompressed\nLightness (J)"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos -67
  disable {{!parent.applyGamutMappingJ}}
 }
 Group {
  name Group2
  label "Re-Generate Iz\nfrom J"
  xpos 450
  ypos 48
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{ZCAM_IzMh_Blink1.referenceWhite}}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 10000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{ZCAM_IzMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 200}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {20 Factors}
  addUserKnob {7 F}
  F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
  addUserKnob {7 F_s}
  F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
  addUserKnob {7 L_A}
  L_A {{"referenceLuminance * backgroundLuminance / 100"}}
  addUserKnob {7 F_b}
  F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
  addUserKnob {7 F_L}
  F_L {{"0.171*pow(L_A, 1/3) * (1-exp(-48/9*L_A))"}}
 }
  BackdropNode {
   inputs 0
   name BackdropNode7
   tile_color 0x666666ff
   label "Reference White"
   note_font_size 20
   xpos 27
   ypos -149
   bdwidth 177
   bdheight 144
  }
  Input {
   inputs 0
   name Input
   xpos -66
   ypos -264
  }
  Dot {
   name Dot1
   xpos -32
   ypos -184
  }
set N2edeb1c0 [stack 0]
  Dot {
   name Dot11
   xpos 114
   ypos -184
  }
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 80
   ypos -112
  }
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name Colorspace2
   xpos 80
   ypos -76
  }
  Expression {
   temp_name0 gain
   temp_expr0 parent.referenceLuminance/g
   expr0 r*gain
   expr1 g*gain
   expr2 b*gain
   name Expression0
   xpos 80
   ypos -50
  }
  Group {
   name XYZ_w_to_Izazbz
   xpos 80
   ypos -26
  }
   Input {
    inputs 0
    name Input1
    xpos 148
    ypos 197
   }
   Expression {
    temp_name0 cb
    temp_expr0 1.15
    temp_name1 cg
    temp_expr1 0.66
    expr0 "(cb*r) - ((cb-1)*b)"
    expr1 "(cg*g) - ((cg-1)*r)"
    expr2 b
    name Expression1
    label "XYZ (D65)\nto\nX'Y'Z (D65)"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 237
   }
   ColorMatrix {
    matrix {
        {0.41478972 0.579999 0.014648}
        {-0.20151 1.120649 0.0531008}
        {-0.0166008 0.2648 0.6684799}
      }
    name ColorMatrix1
    label "X'Y'Z (D65)\nto\nLMS"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 297
   }
   Expression {
    temp_name0 c1
    temp_expr0 "3424 / pow(2,12)"
    temp_name1 c2
    temp_expr1 "2413 / pow(2,7)"
    temp_name2 c3
    temp_expr2 "2392 / pow(2,7)"
    temp_name3 n
    temp_expr3 2610/pow(2,14)
    expr0 "pow( ( c1 + c2 * pow((r/10000),n) ) / ( 1 + c3 * pow((r/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    expr1 "pow( ( c1 + c2 * pow((g/10000),n) ) / ( 1 + c3 * pow((g/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    expr2 "pow( ( c1 + c2 * pow((b/10000),n) ) / ( 1 + c3 * pow((b/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    name Expression2
    label "LMS\nto\nL'M'S'"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 357
   }
   ColorMatrix {
    matrix {
        {0 {1-epsilon} 0}
        {3.524 -4.066708 0.542708}
        {0.199076 1.096799 -1.295875}
      }
    name ColorMatrix2
    label "L'M'S\nto\nIzazbz"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 417
    addUserKnob {20 User}
    addUserKnob {7 epsilon}
    epsilon 3.703522621e-11
   }
   Output {
    name Output1
    xpos 148
    ypos 517
   }
  end_group
  Dot {
   name Dot2
   xpos 114
   ypos 53
  }
push $N2edeb1c0
  MergeExpression {
   inputs 2
   temp_name0 Qzm
   temp_expr0 "pow(parent.F_s, 2.2) * pow(parent.F_b, 0.5) * pow(parent.F_L, 0.2)"
   temp_name1 Qzw
   temp_expr1 "2700 * pow(Ar, (1.6 * parent.F_s) / pow(parent.F_b, 0.12)) * Qzm"
   temp_name2 Izp
   temp_expr2 "pow(parent.F_b, 0.12) / (1.6 * parent.F_s)"
   temp_name3 Izd
   temp_expr3 "2700 * 100 * Qzm"
   expr0 "pow((r * Qzw) / Izd, Izp)"
   channel1 none
   channel2 none
   channel3 none
   name MergeExpression3
   xpos -66
   ypos 50
  }
  Output {
   name Output
   xpos -66
   ypos 117
  }
 end_group
 Dot {
  name Dot45
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos 98
 }
set N2ed36c70 [stack 0]
 Dot {
  name Dot9
  note_font "Bitstream Vera Sans"
  xpos 643
  ypos 98
 }
set N2ed3bb40 [stack 0]
 Group {
  name st2048_6
  label "Lum to PQ (ZCAM)\ninverse"
  xpos 609
  ypos 126
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  direction "ST.2048 -> Luminance (Cd/sqm)"
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N2ed4fc30 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N2ed4fc30
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Multiply {
  channels rgb
  value 1.028552621
  name Multiply16
  label "re-apply luminance shift\nfrom cone fundamentals matrix\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 609
  ypos 168
 }
set N1e9eeff0 [stack 0]
 BlinkScript {
  recompileCount 35
  ProgramGroup 1
  KernelDescription "2 \"SSTSKernel\" iterate pixelWise 3292521f65973146de9ba2803e15c81b8610684f8dcbef3a3fc1382de44823f8 2 \"src\" Read Point \"dst\" Write Point 8 \"lumMid\" Float 1 AAAAAA== \"defaultMin\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMid\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMax\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"coefsLow\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"coefsHigh\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"M1\" Float 9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inverse\" Int 1 AAAAAA== 8 \"lumMid\" 1 1 \"defaultMin\" 3 1 \"defaultMid\" 3 1 \"defaultMax\" 3 1 \"coefsLow\" 1 6 \"coefsHigh\" 1 6 \"M1\" 9 1 \"inverse\" 1 1 4 \"expShift\" Float 1 1 AAAAAA== \"paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel SSTSKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float lumMid;\n    float3 defaultMin;\n    float3 defaultMid;\n    float3 defaultMax;\n    float coefsLow\[6];\n    float coefsHigh\[6];\n    float3x3 M1;\n    int inverse;\n\n  local:\n    float expShift;\n    float3 paramMin;\n    float3 paramMid;\n    float3 paramMax;\n\n  \n  void define()\n  \{\n\n  \}\n\n  float3 vector_dot( float3 v, float3x3 m)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float dot( float3 a, float3 b)\n  \{\n    return (a.x*b.x) + (a.y*b.y) + (a.z*b.z);\n  \}\n\n  \n  float ssts(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float HALF_MIN = 0.0000000596046448;\n\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsLow\[j], coefsLow\[j + 1], coefsLow\[j + 2]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsHigh\[j], coefsHigh\[j + 1], coefsHigh\[j + 2]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return pow(10.0f,logy);\n  \}\n\n  \n  float inv_ssts(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( coefsLow\[i] + coefsLow\[i+1]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( coefsHigh\[i] + coefsHigh\[i+1]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = coefsLow\[0];\n          cf.y = coefsLow\[1];\n          cf.z = coefsLow\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = coefsLow\[1];\n          cf.y = coefsLow\[2];\n          cf.z = coefsLow\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = coefsLow\[2];\n          cf.y = coefsLow\[3];\n          cf.z = coefsLow\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1 );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = coefsHigh\[0];\n          cf.y = coefsHigh\[1];\n          cf.z = coefsHigh\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = coefsHigh\[1];\n          cf.y = coefsHigh\[2];\n          cf.z = coefsHigh\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = coefsHigh\[2];\n          cf.y = coefsHigh\[3];\n          cf.z = coefsHigh\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1);\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return pow(10.0f, logx);\n  \}\n\n\n  void init()\n  \{\n    paramMin = defaultMin;\n    paramMid = defaultMid;\n    paramMax = defaultMax;\n    expShift = log2(inv_ssts(lumMid, defaultMin, paramMid, defaultMax)) - log2(0.18f);\n    paramMin.x = pow(2.0f, (log(paramMin.x) / log(2.0f) - expShift));\n    paramMid.x = pow(2.0f, (log(0.18f     ) / log(2.0f) - expShift));\n    paramMax.x = pow(2.0f, (log(paramMax.x) / log(2.0f) - expShift));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    float3 srcPixel(input.x, input.y, input.z);\n    float3 tsPixel = 0.0f;\n\n    if( inverse )\n    \{\n      tsPixel.x = inv_ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = inv_ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = inv_ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n    else\n    \{\n      tsPixel.x = ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n\n    dst() = float4(tsPixel.x, tsPixel.y, tsPixel.z, input.w);\n  \}\n\};\n"
  rebuild ""
  SSTSKernel_lumMid {{luminances.y}}
  SSTSKernel_defaultMin {{pow(2.,(log(MIN_PT.x)/log(2)))} {MIN_PT.y} {MIN_PT.z}}
  SSTSKernel_defaultMid {{pow(2.,(log(0.18)/log(2)))} {MID_PT.y} {MID_PT.z}}
  SSTSKernel_defaultMax {{pow(2.,(log(MAX_PT.x)/log(2)))} {MAX_PT.y} {MAX_PT.z}}
  SSTSKernel_coefsLow {{"(MIN_PT.z * (log10(MIN_PT.x)-0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"(MIN_PT.z * (log10(MIN_PT.x)+0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"log10(MIN_PT.y) + pctLow*(log10(MID_PT.y)-log10(MIN_PT.y))"} {"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {SSTSKernel_coefsLow.4}}
  SSTSKernel_coefsHigh {{"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"log10(MID_PT.y) + pctHigh*(log10(MAX_PT.y)-log10(MID_PT.y))"} {"(MAX_PT.z * (log10(MAX_PT.x)-0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {"(MAX_PT.z * (log10(MAX_PT.x)+0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {SSTSKernel_coefsHigh.4}}
  SSTSKernel_M1 {
      {0.5 -1 0.5}
      {-1 1 0}
      {0.5 0.5 0}
    }
  SSTSKernel_inverse {{direction}}
  rebuild_finalise ""
  name SSTS_Blink3
  label inverse
  note_font "Bitstream Vera Sans"
  xpos 609
  ypos 228
  addUserKnob {20 User}
  addUserKnob {13 luminances}
  luminances {{parent.ssts_luminance.0} {parent.ssts_luminance.1} {parent.ssts_luminance.2}}
  addUserKnob {4 direction M {forward inverse}}
  direction inverse
  addUserKnob {20 SSTSParams}
  addUserKnob {13 MIN_PT}
  MIN_PT {{0.18*pow(2,minTable(log10(luminances.x)))} {luminances.x} 0}
  addUserKnob {13 MID_PT}
  MID_PT {0.18 4.8 1.55}
  addUserKnob {13 MAX_PT}
  MAX_PT {{0.18*pow(2,maxTable(log10(luminances.z)))} {luminances.z} 0}
  addUserKnob {7 knotIncLow}
  knotIncLow {{"(log10(MID_PT.x) - log10(MIN_PT.x)) / 3"}}
  addUserKnob {7 knotIncHigh}
  knotIncHigh {{"(log10(MAX_PT.x) - log10(MID_PT.x)) / 3"}}
  addUserKnob {7 pctLow}
  pctLow {{bendsLow(log(MIN_PT.x/0.18)/log(2))}}
  addUserKnob {7 pctHigh}
  pctHigh {{bendsHigh(log(MAX_PT.x/0.18)/log(2))}}
  addUserKnob {20 Tables}
  addUserKnob {7 minTable}
  minTable {{curve L l x-4 -15 x-1.69896996 -6.5}}
  addUserKnob {7 maxTable}
  maxTable {{curve L l x1.681241274 6.5 x4 18}}
  addUserKnob {7 bendsLow}
  bendsLow {{curve L l x-15 0.18 x-6.5 0.35}}
  addUserKnob {7 bendsHigh}
  bendsHigh {{curve l x6.5 0.89 x18 0.9}}
  addUserKnob {20 Constants}
  addUserKnob {7 MIN_STOP_SDR R -10 10}
  MIN_STOP_SDR -6.5
  addUserKnob {7 MAX_STOP_SDR R -10 10}
  MAX_STOP_SDR 6.5
  addUserKnob {7 MIN_STOP_RRT R -20 20}
  MIN_STOP_RRT -15
  addUserKnob {7 MAX_STOP_RRT R -20 20}
  MAX_STOP_RRT 18
  addUserKnob {7 MIN_LUM_SDR}
  MIN_LUM_SDR 0.02
  addUserKnob {7 MAX_LUM_SDR R 0 200}
  MAX_LUM_SDR 48
  addUserKnob {7 MIN_LUM_RRT}
  MIN_LUM_RRT 0.0001
  addUserKnob {7 MAX_LUM_RRT R 0 10000}
  MAX_LUM_RRT 10000
  addUserKnob {3 N_KNOTS_LOW}
  N_KNOTS_LOW 4
  addUserKnob {3 N_KNOTS_HIGH}
  N_KNOTS_HIGH 4
 }
set N1e9faf10 [stack 0]
 Multiply {
  channels rgb
  value {{parent.reference_luminance}}
  name Multiply15
  label "1/\[value parent.reference_luminance]\nLum to Exp\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 609
  ypos 276
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply14
  label "remove luminance shift\nfrom cone fundamentals matrix\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 609
  ypos 336
 }
 Group {
  name st2048_5
  label "PQ (ZCAM) to Lum\ninverse"
  xpos 609
  ypos 396
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1ea4f230 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1ea4f230
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
push $N2ed36c70
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy4
  label "apply SSTS"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos 399
  disable {{!parent.applySSTS}}
 }
 Dot {
  name Dot38
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos 450
 }
set N1ea9d230 [stack 0]
 Dot {
  name Dot44
  note_font "Bitstream Vera Sans"
  xpos 605
  ypos 450
 }
set N1eaa2120 [stack 0]
push $N1e9eeff0
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance}}
  name Multiply21
  label "1/\[value parent.reference_luminance]\nLum to Exp\n"
  note_font "Bitstream Vera Sans"
  xpos 825
  ypos 174
 }
set N1eaa7030 [stack 0]
 Dot {
  name Dot56
  note_font "Bitstream Vera Sans"
  xpos 1058
  ypos 189
 }
push $N1e9faf10
 Switch {
  inputs 2
  which {{!parent.applySSTS}}
  name Switch4
  label "dont apply inverse SSTS\nif it has been disabled"
  note_font "Bitstream Vera Sans"
  xpos 1024
  ypos 228
 }
 Expression {
  expr0 "r>0.18 ? 1 : 0"
  name Expression1
  label "mask for values\nabove mid-SSTS"
  note_font "Bitstream Vera Sans"
  xpos 1024
  ypos 282
 }
 Dot {
  name Dot37
  note_font "Bitstream Vera Sans"
  xpos 1058
  ypos 424
 }
push $N1eaa2120
 Dot {
  name Dot52
  note_font "Bitstream Vera Sans"
  xpos 788
  ypos 450
 }
 Dot {
  name Dot53
  note_font "Bitstream Vera Sans"
  xpos 788
  ypos 80
 }
 Dot {
  name Dot46
  note_font "Bitstream Vera Sans"
  xpos 1164
  ypos 80
 }
set N1eadd6d0 [stack 0]
 Shuffle {
  red black
  green black
  blue black
  alpha black
  name Shuffle4
  label "all to zero"
  note_font "Bitstream Vera Sans"
  xpos 1342
  ypos 71
 }
 Dot {
  name Dot48
  note_font "Bitstream Vera Sans"
  xpos 1376
  ypos 124
 }
set N1eaf2e80 [stack 0]
 Dot {
  name Dot49
  note_font "Bitstream Vera Sans"
  xpos 1309
  ypos 124
 }
 Add {
  channels rgb
  value {{parent.ssts_luminance.1}}
  name Add1
  label "Set to post-SSTS\nMid-Luminance"
  note_font "Bitstream Vera Sans"
  xpos 1275
  ypos 151
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply23
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos 1275
  ypos 213
 }
 Group {
  name st2048_7
  label "Lum to PQ (ZCAM)"
  xpos 1275
  ypos 263
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1eb24000 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1eb24000
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
push $N1eaf2e80
 Dot {
  name Dot50
  note_font "Bitstream Vera Sans"
  xpos 1445
  ypos 124
 }
 Add {
  channels rgb
  value 18
  name Add3
  label "Set to pre-SSTS\nMid-Luminance"
  note_font "Bitstream Vera Sans"
  xpos 1411
  ypos 156
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply24
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos 1411
  ypos 215
 }
 Group {
  name st2048_8
  label "Lum to PQ (ZCAM)"
  xpos 1411
  ypos 263
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N1eb8d2f0 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N1eb8d2f0
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Dot {
  name Dot51
  note_font "Bitstream Vera Sans"
  xpos 1445
  ypos 324
 }
 Merge2 {
  inputs 2
  operation minus
  name Merge13
  note_font "Bitstream Vera Sans"
  xpos 1275
  ypos 321
 }
push $N1eadd6d0
 Merge2 {
  inputs 2
  operation plus
  name Merge14
  label "add offset to\nalign mids"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 309
 }
push $N1eaa7030
 BlinkScript {
  recompileCount 35
  ProgramGroup 1
  KernelDescription "2 \"SSTSKernel\" iterate pixelWise 3292521f65973146de9ba2803e15c81b8610684f8dcbef3a3fc1382de44823f8 2 \"src\" Read Point \"dst\" Write Point 8 \"lumMid\" Float 1 AAAAAA== \"defaultMin\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMid\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMax\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"coefsLow\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"coefsHigh\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"M1\" Float 9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inverse\" Int 1 AAAAAA== 8 \"lumMid\" 1 1 \"defaultMin\" 3 1 \"defaultMid\" 3 1 \"defaultMax\" 3 1 \"coefsLow\" 1 6 \"coefsHigh\" 1 6 \"M1\" 9 1 \"inverse\" 1 1 4 \"expShift\" Float 1 1 AAAAAA== \"paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel SSTSKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float lumMid;\n    float3 defaultMin;\n    float3 defaultMid;\n    float3 defaultMax;\n    float coefsLow\[6];\n    float coefsHigh\[6];\n    float3x3 M1;\n    int inverse;\n\n  local:\n    float expShift;\n    float3 paramMin;\n    float3 paramMid;\n    float3 paramMax;\n\n  \n  void define()\n  \{\n\n  \}\n\n  float3 vector_dot( float3 v, float3x3 m)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float dot( float3 a, float3 b)\n  \{\n    return (a.x*b.x) + (a.y*b.y) + (a.z*b.z);\n  \}\n\n  \n  float ssts(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float HALF_MIN = 0.0000000596046448;\n\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsLow\[j], coefsLow\[j + 1], coefsLow\[j + 2]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsHigh\[j], coefsHigh\[j + 1], coefsHigh\[j + 2]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return pow(10.0f,logy);\n  \}\n\n  \n  float inv_ssts(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( coefsLow\[i] + coefsLow\[i+1]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( coefsHigh\[i] + coefsHigh\[i+1]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = coefsLow\[0];\n          cf.y = coefsLow\[1];\n          cf.z = coefsLow\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = coefsLow\[1];\n          cf.y = coefsLow\[2];\n          cf.z = coefsLow\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = coefsLow\[2];\n          cf.y = coefsLow\[3];\n          cf.z = coefsLow\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1 );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = coefsHigh\[0];\n          cf.y = coefsHigh\[1];\n          cf.z = coefsHigh\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = coefsHigh\[1];\n          cf.y = coefsHigh\[2];\n          cf.z = coefsHigh\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = coefsHigh\[2];\n          cf.y = coefsHigh\[3];\n          cf.z = coefsHigh\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1);\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return pow(10.0f, logx);\n  \}\n\n\n  void init()\n  \{\n    paramMin = defaultMin;\n    paramMid = defaultMid;\n    paramMax = defaultMax;\n    expShift = log2(inv_ssts(lumMid, defaultMin, paramMid, defaultMax)) - log2(0.18f);\n    paramMin.x = pow(2.0f, (log(paramMin.x) / log(2.0f) - expShift));\n    paramMid.x = pow(2.0f, (log(0.18f     ) / log(2.0f) - expShift));\n    paramMax.x = pow(2.0f, (log(paramMax.x) / log(2.0f) - expShift));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    float3 srcPixel(input.x, input.y, input.z);\n    float3 tsPixel = 0.0f;\n\n    if( inverse )\n    \{\n      tsPixel.x = inv_ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = inv_ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = inv_ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n    else\n    \{\n      tsPixel.x = ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n\n    dst() = float4(tsPixel.x, tsPixel.y, tsPixel.z, input.w);\n  \}\n\};\n"
  rebuild ""
  SSTSKernel_lumMid {{luminances.y}}
  SSTSKernel_defaultMin {{pow(2.,(log(MIN_PT.x)/log(2)))} {MIN_PT.y} {MIN_PT.z}}
  SSTSKernel_defaultMid {{pow(2.,(log(0.18)/log(2)))} {MID_PT.y} {MID_PT.z}}
  SSTSKernel_defaultMax {{pow(2.,(log(MAX_PT.x)/log(2)))} {MAX_PT.y} {MAX_PT.z}}
  SSTSKernel_coefsLow {{"(MIN_PT.z * (log10(MIN_PT.x)-0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"(MIN_PT.z * (log10(MIN_PT.x)+0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"log10(MIN_PT.y) + pctLow*(log10(MID_PT.y)-log10(MIN_PT.y))"} {"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {SSTSKernel_coefsLow.4}}
  SSTSKernel_coefsHigh {{"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"log10(MID_PT.y) + pctHigh*(log10(MAX_PT.y)-log10(MID_PT.y))"} {"(MAX_PT.z * (log10(MAX_PT.x)-0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {"(MAX_PT.z * (log10(MAX_PT.x)+0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {SSTSKernel_coefsHigh.4}}
  SSTSKernel_M1 {
      {0.5 -1 0.5}
      {-1 1 0}
      {0.5 0.5 0}
    }
  SSTSKernel_inverse {{direction}}
  rebuild_finalise ""
  name SSTS_Blink1
  note_font "Bitstream Vera Sans"
  xpos 825
  ypos 297
  addUserKnob {20 User}
  addUserKnob {13 luminances}
  luminances {{parent.ssts_luminance.0} {parent.ssts_luminance.1} {parent.ssts_luminance.2}}
  addUserKnob {4 direction M {forward inverse}}
  addUserKnob {20 SSTSParams}
  addUserKnob {13 MIN_PT}
  MIN_PT {{0.18*pow(2,minTable(log10(luminances.x)))} {luminances.x} 0}
  addUserKnob {13 MID_PT}
  MID_PT {0.18 4.8 1.55}
  addUserKnob {13 MAX_PT}
  MAX_PT {{0.18*pow(2,maxTable(log10(luminances.z)))} {luminances.z} 0}
  addUserKnob {7 knotIncLow}
  knotIncLow {{"(log10(MID_PT.x) - log10(MIN_PT.x)) / 3"}}
  addUserKnob {7 knotIncHigh}
  knotIncHigh {{"(log10(MAX_PT.x) - log10(MID_PT.x)) / 3"}}
  addUserKnob {7 pctLow}
  pctLow {{bendsLow(log(MIN_PT.x/0.18)/log(2))}}
  addUserKnob {7 pctHigh}
  pctHigh {{bendsHigh(log(MAX_PT.x/0.18)/log(2))}}
  addUserKnob {20 Tables}
  addUserKnob {7 minTable}
  minTable {{curve L l x-4 -15 x-1.69896996 -6.5}}
  addUserKnob {7 maxTable}
  maxTable {{curve L l x1.681241274 6.5 x4 18}}
  addUserKnob {7 bendsLow}
  bendsLow {{curve L l x-15 0.18 x-6.5 0.35}}
  addUserKnob {7 bendsHigh}
  bendsHigh {{curve l x6.5 0.89 x18 0.9}}
  addUserKnob {20 Constants}
  addUserKnob {7 MIN_STOP_SDR R -10 10}
  MIN_STOP_SDR -6.5
  addUserKnob {7 MAX_STOP_SDR R -10 10}
  MAX_STOP_SDR 6.5
  addUserKnob {7 MIN_STOP_RRT R -20 20}
  MIN_STOP_RRT -15
  addUserKnob {7 MAX_STOP_RRT R -20 20}
  MAX_STOP_RRT 18
  addUserKnob {7 MIN_LUM_SDR}
  MIN_LUM_SDR 0.02
  addUserKnob {7 MAX_LUM_SDR R 0 200}
  MAX_LUM_SDR 48
  addUserKnob {7 MIN_LUM_RRT}
  MIN_LUM_RRT 0.0001
  addUserKnob {7 MAX_LUM_RRT R 0 10000}
  MAX_LUM_RRT 10000
  addUserKnob {3 N_KNOTS_LOW}
  N_KNOTS_LOW 4
  addUserKnob {3 N_KNOTS_HIGH}
  N_KNOTS_HIGH 4
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply26
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos 825
  ypos 333
 }
 Group {
  name st2048_9
  label "Lum to PQ (ZCAM)"
  xpos 825
  ypos 381
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N3ab97850 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N3ab97850
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
push $N2ed3bb40
 Dot {
  name Dot54
  note_font "Bitstream Vera Sans"
  xpos 969
  ypos 98
 }
 Switch {
  inputs 2
  which {{!parent.applySSTS}}
  name Switch5
  label "apply forward SSTS\nif it has been disabled"
  note_font "Bitstream Vera Sans"
  xpos 935
  ypos 373
 }
 Merge2 {
  inputs 2
  operation minus
  name Merge15
  label "diff tonescale"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 379
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge16
  label "remove toe"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 415
 }
 Multiply {
  channels rgb
  value {{parent.desatHighlights}}
  name Multiply25
  label "desat scale"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 451
 }
 Group {
  name SoftclipExpression3
  label "avoid negative values for M"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 487
  addUserKnob {20 User}
  addUserKnob {18 clip_to}
  clip_to 0.9
  addUserKnob {6 clip_to_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 clip_to_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 clip_to_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 threshold}
  threshold 0.8
  addUserKnob {6 threshold_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {4 direction M {forward inverse}}
  addUserKnob {7 mix}
  mix 1
 }
  Input {
   inputs 0
   name Input1
   xpos -284
   ypos 135
  }
  Multiply {
   value {{1/parent.clip_to.r} {1/parent.clip_to.g} {1/parent.clip_to.b} 1}
   name Multiply1
   note_font "Bitstream Vera Sans"
   xpos -284
   ypos 159
  }
set N3ac226e0 [stack 0]
  Expression {
   temp_name0 one_minus_e
   temp_expr0 "1 - pow(10,-15)"
   temp_name1 maxr
   temp_expr1 "(pow(threshold.r, 2) - 2 * threshold.r * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   temp_name2 maxg
   temp_expr2 "(pow(threshold.g, 2) - 2 * threshold.g * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   temp_name3 maxb
   temp_expr3 "(pow(threshold.b, 2) - 2 * threshold.b * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   expr0 " threshold.r < 1 ? r >= 1 ? maxr : r > threshold.r ? (pow(threshold.r, 2) - 2 * threshold.r * r + r ) / ( 1 - r ) : r : r"
   expr1 " threshold.g < 1 ? g >= 1 ? maxg : g > threshold.g ? (pow(threshold.g, 2) - 2 * threshold.g * g + g ) / ( 1 - g ) : g : g"
   expr2 " threshold.b < 1 ? b >= 1 ? maxb : b > threshold.b ? (pow(threshold.b, 2) - 2 * threshold.b * b + b ) / ( 1 - b ) : b : b"
   expr3 a
   mix {{parent.mix}}
   name Expression2
   label inverse
   xpos -222
   ypos 257
   addUserKnob {20 User}
   addUserKnob {18 threshold}
   threshold {{parent.threshold.r} {parent.threshold.g} {parent.threshold.b}}
   addUserKnob {6 threshold_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  }
push $N3ac226e0
  Expression {
   expr0 "threshold.r < 1 ? r > threshold.r ? ( -1 / (( r - threshold.r ) / ( 1 - threshold.r ) +1 ) +1 ) * ( 1 - threshold.r ) + threshold.r : r : r"
   expr1 "threshold.g < 1 ? g > threshold.g ? ( -1 / (( g - threshold.g ) / ( 1 - threshold.g ) +1 ) +1 ) * ( 1 - threshold.g ) + threshold.g : g : g"
   expr2 "threshold.b < 1 ? b > threshold.b ? ( -1 / (( b - threshold.b ) / ( 1 - threshold.b ) +1 ) +1 ) * ( 1 - threshold.b ) + threshold.b : b : b"
   expr3 a
   mix {{parent.mix}}
   name Expression1
   label forward
   xpos -349
   ypos 258
   addUserKnob {20 User}
   addUserKnob {18 threshold_1 l threshold}
   threshold_1 {{parent.threshold.r} {parent.threshold.g} {parent.threshold.b}}
   addUserKnob {6 threshold_1_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   note_font "Bitstream Vera Sans"
   xpos -287
   ypos 356
  }
  Multiply {
   value {{parent.clip_to.r} {parent.clip_to.g} {parent.clip_to.b} 1}
   name Multiply2
   note_font "Bitstream Vera Sans"
   xpos -287
   ypos 380
  }
  Output {
   name Output1
   xpos -287
   ypos 463
  }
 end_group
 Clamp {
  channels rgb
  name Clamp4
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 523
 }
 Invert {
  channels rgb
  name Invert3
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 547
 }
 Shuffle {
  red white
  green red
  blue white
  alpha white
  name Shuffle5
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos 1130
  ypos 571
 }
 Merge2 {
  inputs 2
  operation divide
  name Merge12
  label "highlight de-sat\ninverse"
  note_font "Bitstream Vera Sans"
  xpos 571
  ypos 565
 }
push $N1ea9d230
 Switch {
  inputs 2
  which {{parent.applyHighlightDesat}}
  name Switch3
  label "apply\nhighlight desat"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos 565
 }
 Group {
  name ZCAM_IzMh_Blink3
  label "XYZ to IzMh"
  note_font "Bitstream Vera Sans"
  xpos 450
  ypos 696
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.illuminant_in}}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2048 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N3acc8240 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N3accd160 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N3accd160
  Colorspace {
   illuminant_in {{parent.parent.illuminant_in}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 213
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N3acc8240
  BlinkScript {
   inputs 3
   recompileCount 70
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_IzMh_Kernel_v02\" iterate pixelWise 699a9a103a452f3a77c4ee9405f1b913eb2b3f7aefbddb2581496e804e75cd10 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_IzMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_IzMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 IzMh = 0.0f;\n\n    IzMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+IzMh.z));\n    IzMh.x = Izazbz.x;\n    IzMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return IzMh;\n  \}\n\n\n  float3 IzMh_to_Izazbz( float3 IzMh, float refWhiteIz)\n  \{\n    float ez = 1.015f + cos(radians(89.038f+IzMh.z));\n    float hzr = radians(IzMh.z);\n    float Czp = spow((IzMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * pow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( IzMh.x, Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_IzMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_IzMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_IzMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(IzMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_IzMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_IzMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_IzMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_IzMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_IzMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_IzMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_IzMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_IzMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_IzMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_IzMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_IzMh_Kernel_v02_L_A))"}}
   ZCAM_IzMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_IzMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_IzMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance}}
  name Multiply17
  label "x\[value parent.reference_luminance]\nRel. Exp. to Cd/sqm\ninverse"
  xpos 450
  ypos 737
  disable {{"Colorspace4.colorspace_out == 31"}}
 }
 Colorspace {
  colorspace_in CIE-XYZ
  colorspace_out {{Colorspace1.colorspace_in}}
  illuminant_out {{Colorspace1.illuminant_in}}
  primary_out {{Colorspace1.primary_in}}
  name Colorspace4
  label "XYZ -> Input"
  xpos 450
  ypos 789
 }
 Dot {
  name Dot30
  note_font "Bitstream Vera Sans"
  xpos 484
  ypos 909
 }
 Dot {
  name Dot29
  note_font "Bitstream Vera Sans"
  xpos -461
  ypos 909
 }
push $N1f56a430
 Dot {
  name Dot16
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos -1035
 }
 Clamp {
  channels rgb
  minimum -65504
  minimum_enable false
  maximum 65504
  name Clamp1
  label "Clamp inf to\n+/-half max"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos -909
 }
 Colorspace {
  illuminant_in ACES
  primary_in ACES
  colorspace_out CIE-XYZ
  name Colorspace1
  label "Input -> XYZ"
  xpos -1148
  ypos -859
 }
 Multiply {
  channels rgb
  value {{parent.reference_luminance}}
  name Multiply1
  label "x\[value parent.reference_luminance]\nRel. Exp. to Cd/sqm"
  xpos -1148
  ypos -818
  disable {{"Colorspace1.colorspace_in == 31"}}
 }
 Group {
  name ZCAM_IzMh_Blink1
  label "XYZ to IzMh"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos -768
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.illuminant_in}}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2048 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N3adbb430 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N3adc03f0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N3adc03f0
  Colorspace {
   illuminant_in {{parent.parent.illuminant_in}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 213
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N3adbb430
  BlinkScript {
   inputs 3
   recompileCount 70
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_IzMh_Kernel_v02\" iterate pixelWise 699a9a103a452f3a77c4ee9405f1b913eb2b3f7aefbddb2581496e804e75cd10 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_IzMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_IzMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 IzMh = 0.0f;\n\n    IzMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+IzMh.z));\n    IzMh.x = Izazbz.x;\n    IzMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return IzMh;\n  \}\n\n\n  float3 IzMh_to_Izazbz( float3 IzMh, float refWhiteIz)\n  \{\n    float ez = 1.015f + cos(radians(89.038f+IzMh.z));\n    float hzr = radians(IzMh.z);\n    float Czp = spow((IzMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * pow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( IzMh.x, Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_IzMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_IzMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_IzMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(IzMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_IzMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_IzMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_IzMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_IzMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_IzMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_IzMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_IzMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_IzMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_IzMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_IzMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_IzMh_Kernel_v02_L_A))"}}
   ZCAM_IzMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_IzMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_IzMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Dot {
  name Dot5
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos -603
 }
set N3ae31ae0 [stack 0]
 Dot {
  name Dot11
  note_font "Bitstream Vera Sans"
  xpos -1309
  ypos -603
 }
set N3ae36910 [stack 0]
 Group {
  name st2048_3
  label "PQ (ZCAM) to Lum"
  xpos -1343
  ypos -480
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  direction "ST.2048 -> Luminance (Cd/sqm)"
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N3ae4a810 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N3ae4a810
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Multiply {
  channels rgb
  value 1.028552621
  name Multiply10
  label "remove luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos -1343
  ypos -448
 }
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance}}
  name Multiply11
  label "1/\[value parent.reference_luminance]\nLum to Exp"
  note_font "Bitstream Vera Sans"
  xpos -1343
  ypos -400
 }
set N3ae93bb0 [stack 0]
 Expression {
  expr0 "r>0.18 ? 1 : 0"
  name Expression5
  label "mask for values\nabove mid-SSTS"
  note_font "Bitstream Vera Sans"
  xpos -1453
  ypos -400
 }
 Dot {
  name Dot8
  note_font "Bitstream Vera Sans"
  xpos -1419
  ypos -282
 }
push $N3ae36910
 Dot {
  name Dot7
  note_font "Bitstream Vera Sans"
  xpos -1608
  ypos -603
 }
set N3aeb31b0 [stack 0]
 Shuffle {
  red black
  green black
  blue black
  alpha black
  name Shuffle3
  label "all to zero"
  note_font "Bitstream Vera Sans"
  xpos -1813
  ypos -612
 }
 Dot {
  name Dot43
  note_font "Bitstream Vera Sans"
  xpos -1779
  ypos -576
 }
set N3aec8980 [stack 0]
 Dot {
  name Dot42
  note_font "Bitstream Vera Sans"
  xpos -1718
  ypos -576
 }
 Add {
  channels rgb
  value {{parent.ssts_luminance.1}}
  name Add4
  label "Set to post-SSTS\nMid-Luminance"
  note_font "Bitstream Vera Sans"
  xpos -1752
  ypos -549
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply9
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos -1752
  ypos -487
 }
 Group {
  name st2048_1
  label "Lum to PQ (ZCAM)"
  xpos -1752
  ypos -437
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N3aef9f50 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N3aef9f50
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
push $N3aec8980
 Dot {
  name Dot41
  note_font "Bitstream Vera Sans"
  xpos -1824
  ypos -576
 }
 Add {
  channels rgb
  value 18
  name Add5
  label "Set to pre-SSTS\nMid-Luminance"
  note_font "Bitstream Vera Sans"
  xpos -1858
  ypos -544
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply18
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos -1858
  ypos -485
 }
 Group {
  name st2048_2
  label "Lum to PQ (ZCAM)"
  xpos -1858
  ypos -437
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N3af63350 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N3af63350
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Dot {
  name Dot35
  note_font "Bitstream Vera Sans"
  xpos -1824
  ypos -402
 }
 Merge2 {
  inputs 2
  operation minus
  name Merge5
  note_font "Bitstream Vera Sans"
  xpos -1752
  ypos -405
 }
push $N3aeb31b0
 Merge2 {
  inputs 2
  operation plus
  name Merge11
  label "add offset to\nalign mids"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -417
 }
 Expression {
  temp_name0 HALF_MIN
  temp_expr0 0.0000000596046448
  expr0 log10(max(HALF_MIN,r))
  channel1 none
  channel2 none
  channel3 none
  name Expression3
  label log10
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -369
 }
push $N3ae93bb0
 BlinkScript {
  recompileCount 35
  ProgramGroup 1
  KernelDescription "2 \"SSTSKernel\" iterate pixelWise 3292521f65973146de9ba2803e15c81b8610684f8dcbef3a3fc1382de44823f8 2 \"src\" Read Point \"dst\" Write Point 8 \"lumMid\" Float 1 AAAAAA== \"defaultMin\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMid\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"defaultMax\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"coefsLow\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"coefsHigh\" Float 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"M1\" Float 9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inverse\" Int 1 AAAAAA== 8 \"lumMid\" 1 1 \"defaultMin\" 3 1 \"defaultMid\" 3 1 \"defaultMax\" 3 1 \"coefsLow\" 1 6 \"coefsHigh\" 1 6 \"M1\" 9 1 \"inverse\" 1 1 4 \"expShift\" Float 1 1 AAAAAA== \"paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel SSTSKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float lumMid;\n    float3 defaultMin;\n    float3 defaultMid;\n    float3 defaultMax;\n    float coefsLow\[6];\n    float coefsHigh\[6];\n    float3x3 M1;\n    int inverse;\n\n  local:\n    float expShift;\n    float3 paramMin;\n    float3 paramMid;\n    float3 paramMax;\n\n  \n  void define()\n  \{\n\n  \}\n\n  float3 vector_dot( float3 v, float3x3 m)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float dot( float3 a, float3 b)\n  \{\n    return (a.x*b.x) + (a.y*b.y) + (a.z*b.z);\n  \}\n\n  \n  float ssts(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float HALF_MIN = 0.0000000596046448;\n\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsLow\[j], coefsLow\[j + 1], coefsLow\[j + 2]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(coefsHigh\[j], coefsHigh\[j + 1], coefsHigh\[j + 2]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( cf, M1));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return pow(10.0f,logy);\n  \}\n\n  \n  float inv_ssts(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( coefsLow\[i] + coefsLow\[i+1]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( coefsHigh\[i] + coefsHigh\[i+1]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = coefsLow\[0];\n          cf.y = coefsLow\[1];\n          cf.z = coefsLow\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = coefsLow\[1];\n          cf.y = coefsLow\[2];\n          cf.z = coefsLow\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = coefsLow\[2];\n          cf.y = coefsLow\[3];\n          cf.z = coefsLow\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1 );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = coefsHigh\[0];\n          cf.y = coefsHigh\[1];\n          cf.z = coefsHigh\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = coefsHigh\[1];\n          cf.y = coefsHigh\[2];\n          cf.z = coefsHigh\[3];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = coefsHigh\[2];\n          cf.y = coefsHigh\[3];\n          cf.z = coefsHigh\[4];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( cf, M1);\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return pow(10.0f, logx);\n  \}\n\n\n  void init()\n  \{\n    paramMin = defaultMin;\n    paramMid = defaultMid;\n    paramMax = defaultMax;\n    expShift = log2(inv_ssts(lumMid, defaultMin, paramMid, defaultMax)) - log2(0.18f);\n    paramMin.x = pow(2.0f, (log(paramMin.x) / log(2.0f) - expShift));\n    paramMid.x = pow(2.0f, (log(0.18f     ) / log(2.0f) - expShift));\n    paramMax.x = pow(2.0f, (log(paramMax.x) / log(2.0f) - expShift));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    float3 srcPixel(input.x, input.y, input.z);\n    float3 tsPixel = 0.0f;\n\n    if( inverse )\n    \{\n      tsPixel.x = inv_ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = inv_ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = inv_ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n    else\n    \{\n      tsPixel.x = ssts(srcPixel.x, paramMin, paramMid, paramMax);\n      tsPixel.y = ssts(srcPixel.y, paramMin, paramMid, paramMax);\n      tsPixel.z = ssts(srcPixel.z, paramMin, paramMid, paramMax);\n    \}\n\n    dst() = float4(tsPixel.x, tsPixel.y, tsPixel.z, input.w);\n  \}\n\};\n"
  rebuild ""
  SSTSKernel_lumMid {{luminances.y}}
  SSTSKernel_defaultMin {{pow(2.,(log(MIN_PT.x)/log(2)))} {MIN_PT.y} {MIN_PT.z}}
  SSTSKernel_defaultMid {{pow(2.,(log(0.18)/log(2)))} {MID_PT.y} {MID_PT.z}}
  SSTSKernel_defaultMax {{pow(2.,(log(MAX_PT.x)/log(2)))} {MAX_PT.y} {MAX_PT.z}}
  SSTSKernel_coefsLow {{"(MIN_PT.z * (log10(MIN_PT.x)-0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"(MIN_PT.z * (log10(MIN_PT.x)+0.5*knotIncLow)) + ( log10(MIN_PT.y) - MIN_PT.z * log10(MIN_PT.x))"} {"log10(MIN_PT.y) + pctLow*(log10(MID_PT.y)-log10(MIN_PT.y))"} {"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncLow)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {SSTSKernel_coefsLow.4}}
  SSTSKernel_coefsHigh {{"(MID_PT.z * (log10(MID_PT.x)-0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"(MID_PT.z * (log10(MID_PT.x)+0.5*knotIncHigh)) + ( log10(MID_PT.y) - MID_PT.z * log10(MID_PT.x))"} {"log10(MID_PT.y) + pctHigh*(log10(MAX_PT.y)-log10(MID_PT.y))"} {"(MAX_PT.z * (log10(MAX_PT.x)-0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {"(MAX_PT.z * (log10(MAX_PT.x)+0.5*knotIncHigh)) + ( log10(MAX_PT.y) - MAX_PT.z * log10(MAX_PT.x))"} {SSTSKernel_coefsHigh.4}}
  SSTSKernel_M1 {
      {0.5 -1 0.5}
      {-1 1 0}
      {0.5 0.5 0}
    }
  SSTSKernel_inverse {{direction}}
  rebuild_finalise ""
  name SSTS_Blink2
  note_font "Bitstream Vera Sans"
  xpos -1343
  ypos -352
  addUserKnob {20 User}
  addUserKnob {13 luminances}
  luminances {{parent.ssts_luminance.0} {parent.ssts_luminance.1} {parent.ssts_luminance.2}}
  addUserKnob {4 direction M {forward inverse}}
  addUserKnob {20 SSTSParams}
  addUserKnob {13 MIN_PT}
  MIN_PT {{0.18*pow(2,minTable(log10(luminances.x)))} {luminances.x} 0}
  addUserKnob {13 MID_PT}
  MID_PT {0.18 4.8 1.55}
  addUserKnob {13 MAX_PT}
  MAX_PT {{0.18*pow(2,maxTable(log10(luminances.z)))} {luminances.z} 0}
  addUserKnob {7 knotIncLow}
  knotIncLow {{"(log10(MID_PT.x) - log10(MIN_PT.x)) / 3"}}
  addUserKnob {7 knotIncHigh}
  knotIncHigh {{"(log10(MAX_PT.x) - log10(MID_PT.x)) / 3"}}
  addUserKnob {7 pctLow}
  pctLow {{bendsLow(log(MIN_PT.x/0.18)/log(2))}}
  addUserKnob {7 pctHigh}
  pctHigh {{bendsHigh(log(MAX_PT.x/0.18)/log(2))}}
  addUserKnob {20 Tables}
  addUserKnob {7 minTable}
  minTable {{curve L l x-4 -15 x-1.69896996 -6.5}}
  addUserKnob {7 maxTable}
  maxTable {{curve L l x1.681241274 6.5 x4 18}}
  addUserKnob {7 bendsLow}
  bendsLow {{curve L l x-15 0.18 x-6.5 0.35}}
  addUserKnob {7 bendsHigh}
  bendsHigh {{curve l x6.5 0.89 x18 0.9}}
  addUserKnob {20 Constants}
  addUserKnob {7 MIN_STOP_SDR R -10 10}
  MIN_STOP_SDR -6.5
  addUserKnob {7 MAX_STOP_SDR R -10 10}
  MAX_STOP_SDR 6.5
  addUserKnob {7 MIN_STOP_RRT R -20 20}
  MIN_STOP_RRT -15
  addUserKnob {7 MAX_STOP_RRT R -20 20}
  MAX_STOP_RRT 18
  addUserKnob {7 MIN_LUM_SDR}
  MIN_LUM_SDR 0.02
  addUserKnob {7 MAX_LUM_SDR R 0 200}
  MAX_LUM_SDR 48
  addUserKnob {7 MIN_LUM_RRT}
  MIN_LUM_RRT 0.0001
  addUserKnob {7 MAX_LUM_RRT R 0 10000}
  MAX_LUM_RRT 10000
  addUserKnob {3 N_KNOTS_LOW}
  N_KNOTS_LOW 4
  addUserKnob {3 N_KNOTS_HIGH}
  N_KNOTS_HIGH 4
 }
 Multiply {
  channels rgb
  value 0.9722396415
  name Multiply12
  label "re-apply luminance shift\nfrom cone fundamentals matrix"
  note_font "Bitstream Vera Sans"
  xpos -1343
  ypos -316
 }
 Group {
  name st2048_4
  label "Lum to PQ (ZCAM)"
  xpos -1343
  ypos -268
  addUserKnob {20 User}
  addUserKnob {4 direction M {"Luminance (Cd/sqm) -> ST.2048" "ST.2048 -> Luminance (Cd/sqm)"}}
  addUserKnob {7 peakLuminance R 0 10000}
  peakLuminance 10000
  addUserKnob {26 ""}
  addUserKnob {26 m2_override_desc l "" +STARTLINE T "ZCAM uses a different exponent (rho) in its PQ function than ST.2084 (m2)"}
  addUserKnob {7 m2_override R 0 200}
  m2_override {{"1.7 * 2523 / pow(2,5)"}}
 }
  Input {
   inputs 0
   name Input1
   xpos 829
   ypos 200
  }
  Dot {
   name Dot17
   xpos 863
   ypos 240
  }
set N3b01cb00 [stack 0]
  Dot {
   name Dot27
   xpos 916
   ypos 240
  }
  Expression {
   temp_name0 V_pr
   temp_expr0 "pow(r, 1/m_2)"
   temp_name1 V_pg
   temp_expr1 "pow(g, 1/m_2)"
   temp_name2 V_pb
   temp_expr2 "pow(b, 1/m_2)"
   expr0 "pow((max(0.0, V_pr - c_1) / (c_2 - c_3 * V_pr)), 1/m_1)*L_p"
   expr1 "pow((max(0.0, V_pg - c_1) / (c_2 - c_3 * V_pg)), 1/m_1)*L_p"
   expr2 "pow((max(0.0, V_pb - c_1) / (c_2 - c_3 * V_pb)), 1/m_1)*L_p"
   channel3 none
   name from_st2048
   xpos 882
   ypos 285
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
push $N3b01cb00
  Dot {
   name Dot26
   xpos 810
   ypos 240
  }
  Expression {
   temp_name0 Y_pr
   temp_expr0 "pow(r / L_p, m_1)"
   temp_name1 Y_pg
   temp_expr1 "pow(g / L_p, m_1)"
   temp_name2 Y_pb
   temp_expr2 "pow(b / L_p, m_1)"
   expr0 "pow((c_1 + c_2 * Y_pr) / (c_3 * Y_pr + 1), m_2)"
   expr1 "pow((c_1 + c_2 * Y_pg) / (c_3 * Y_pg + 1), m_2)"
   expr2 "pow((c_1 + c_2 * Y_pb) / (c_3 * Y_pb + 1), m_2)"
   channel3 none
   name to_st2084
   xpos 776
   ypos 286
   addUserKnob {20 User}
   addUserKnob {7 m_1}
   m_1 {{"2610 / 4096 * (1 / 4)"}}
   addUserKnob {7 m_2}
   m_2 {{parent.m2_override}}
   addUserKnob {7 c_1}
   c_1 {{"3424 / 4096"}}
   addUserKnob {7 c_2}
   c_2 {{"2413 / 4096 * 32"}}
   addUserKnob {7 c_3}
   c_3 {{"2392 / 4096 * 32"}}
   addUserKnob {7 L_p R 0 10000}
   L_p {{parent.peakLuminance}}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   xpos 835
   ypos 347
  }
  Output {
   name Output1
   xpos 835
   ypos 447
  }
 end_group
 Dot {
  name Dot40
  note_font "Bitstream Vera Sans"
  xpos -1309
  ypos -226
 }
set N3b05a070 [stack 0]
 Dot {
  name Dot6
  note_font "Bitstream Vera Sans"
  xpos -1452
  ypos -226
 }
 Dot {
  name Dot10
  note_font "Bitstream Vera Sans"
  xpos -1452
  ypos -318
 }
 Expression {
  temp_name0 HALF_MIN
  temp_expr0 0.0000000596046448
  expr0 log10(max(HALF_MIN,r))
  channel1 none
  channel2 none
  channel3 none
  name Expression2
  label log10
  note_font "Bitstream Vera Sans"
  xpos -1544
  ypos -327
 }
 Merge2 {
  inputs 2
  operation minus
  name Merge3
  label "diff tonescale"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -327
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge6
  label "remove toe"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -291
 }
 Multiply {
  channels rgb
  value {{parent.desatHighlights}}
  name Multiply4
  label "desat scale"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -255
 }
 Group {
  name SoftclipExpression2
  label "avoid negative values for M"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -219
  addUserKnob {20 User}
  addUserKnob {18 clip_to}
  clip_to 0.9
  addUserKnob {6 clip_to_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 clip_to_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 clip_to_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 threshold}
  threshold 0.8
  addUserKnob {6 threshold_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {4 direction M {forward inverse}}
  addUserKnob {7 mix}
  mix 1
 }
  Input {
   inputs 0
   name Input1
   xpos -284
   ypos 135
  }
  Multiply {
   value {{1/parent.clip_to.r} {1/parent.clip_to.g} {1/parent.clip_to.b} 1}
   name Multiply1
   note_font "Bitstream Vera Sans"
   xpos -284
   ypos 159
  }
set N3b0b7670 [stack 0]
  Expression {
   temp_name0 one_minus_e
   temp_expr0 "1 - pow(10,-15)"
   temp_name1 maxr
   temp_expr1 "(pow(threshold.r, 2) - 2 * threshold.r * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   temp_name2 maxg
   temp_expr2 "(pow(threshold.g, 2) - 2 * threshold.g * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   temp_name3 maxb
   temp_expr3 "(pow(threshold.b, 2) - 2 * threshold.b * one_minus_e + one_minus_e ) / ( 1 - one_minus_e )"
   expr0 " threshold.r < 1 ? r >= 1 ? maxr : r > threshold.r ? (pow(threshold.r, 2) - 2 * threshold.r * r + r ) / ( 1 - r ) : r : r"
   expr1 " threshold.g < 1 ? g >= 1 ? maxg : g > threshold.g ? (pow(threshold.g, 2) - 2 * threshold.g * g + g ) / ( 1 - g ) : g : g"
   expr2 " threshold.b < 1 ? b >= 1 ? maxb : b > threshold.b ? (pow(threshold.b, 2) - 2 * threshold.b * b + b ) / ( 1 - b ) : b : b"
   expr3 a
   mix {{parent.mix}}
   name Expression2
   label inverse
   xpos -222
   ypos 257
   addUserKnob {20 User}
   addUserKnob {18 threshold}
   threshold {{parent.threshold.r} {parent.threshold.g} {parent.threshold.b}}
   addUserKnob {6 threshold_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  }
push $N3b0b7670
  Expression {
   expr0 "threshold.r < 1 ? r > threshold.r ? ( -1 / (( r - threshold.r ) / ( 1 - threshold.r ) +1 ) +1 ) * ( 1 - threshold.r ) + threshold.r : r : r"
   expr1 "threshold.g < 1 ? g > threshold.g ? ( -1 / (( g - threshold.g ) / ( 1 - threshold.g ) +1 ) +1 ) * ( 1 - threshold.g ) + threshold.g : g : g"
   expr2 "threshold.b < 1 ? b > threshold.b ? ( -1 / (( b - threshold.b ) / ( 1 - threshold.b ) +1 ) +1 ) * ( 1 - threshold.b ) + threshold.b : b : b"
   expr3 a
   mix {{parent.mix}}
   name Expression1
   label forward
   xpos -349
   ypos 258
   addUserKnob {20 User}
   addUserKnob {18 threshold_1 l threshold}
   threshold_1 {{parent.threshold.r} {parent.threshold.g} {parent.threshold.b}}
   addUserKnob {6 threshold_1_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 threshold_1_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  }
  Switch {
   inputs 2
   which {{parent.direction}}
   name Switch2
   note_font "Bitstream Vera Sans"
   xpos -287
   ypos 356
  }
  Multiply {
   value {{parent.clip_to.r} {parent.clip_to.g} {parent.clip_to.b} 1}
   name Multiply2
   note_font "Bitstream Vera Sans"
   xpos -287
   ypos 380
  }
  Output {
   name Output1
   xpos -287
   ypos 463
  }
 end_group
 Clamp {
  channels rgb
  name Clamp2
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -183
 }
 Invert {
  channels rgb
  name Invert1
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -159
 }
 Shuffle {
  red white
  green red
  blue white
  alpha white
  name Shuffle2
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1642
  ypos -135
 }
push $N3b05a070
push $N3ae31ae0
 Dot {
  name Dot13
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos -226
 }
set N3b12e0c0 [stack 0]
 Switch {
  inputs 2
  which {{parent.applySSTS}}
  name Switch2
  label "apply SSTS"
  note_font "Bitstream Vera Sans"
  xpos -1258
  ypos -235
 }
 Group {
  name Group1
  label "Re-Generate J\nfrom Iz"
  xpos -1258
  ypos -168
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{ZCAM_IzMh_Blink1.referenceWhite}}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 10000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{ZCAM_IzMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 200}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {20 Factors}
  addUserKnob {7 F}
  F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
  addUserKnob {7 F_s}
  F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
  addUserKnob {7 L_A}
  L_A {{"referenceLuminance * backgroundLuminance / 100"}}
  addUserKnob {7 F_b}
  F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
  addUserKnob {7 F_L}
  F_L {{"0.171*pow(L_A, 1/3) * (1-exp(-48/9*L_A))"}}
 }
  BackdropNode {
   inputs 0
   name BackdropNode7
   tile_color 0x666666ff
   label "Reference White"
   note_font_size 20
   xpos 27
   ypos -149
   bdwidth 177
   bdheight 144
  }
  Input {
   inputs 0
   name Input
   xpos -66
   ypos -264
  }
  Dot {
   name Dot1
   xpos -32
   ypos -184
  }
set N3b1524a0 [stack 0]
  Dot {
   name Dot11
   xpos 114
   ypos -184
  }
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 80
   ypos -112
  }
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name Colorspace2
   xpos 80
   ypos -76
  }
  Expression {
   temp_name0 gain
   temp_expr0 parent.referenceLuminance/g
   expr0 r*gain
   expr1 g*gain
   expr2 b*gain
   name Expression0
   xpos 80
   ypos -50
  }
  Group {
   name XYZ_w_to_Izazbz
   xpos 80
   ypos -26
  }
   Input {
    inputs 0
    name Input1
    xpos 148
    ypos 197
   }
   Expression {
    temp_name0 cb
    temp_expr0 1.15
    temp_name1 cg
    temp_expr1 0.66
    expr0 "(cb*r) - ((cb-1)*b)"
    expr1 "(cg*g) - ((cg-1)*r)"
    expr2 b
    name Expression1
    label "XYZ (D65)\nto\nX'Y'Z (D65)"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 237
   }
   ColorMatrix {
    matrix {
        {0.41478972 0.579999 0.014648}
        {-0.20151 1.120649 0.0531008}
        {-0.0166008 0.2648 0.6684799}
      }
    name ColorMatrix1
    label "X'Y'Z (D65)\nto\nLMS"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 297
   }
   Expression {
    temp_name0 c1
    temp_expr0 "3424 / pow(2,12)"
    temp_name1 c2
    temp_expr1 "2413 / pow(2,7)"
    temp_name2 c3
    temp_expr2 "2392 / pow(2,7)"
    temp_name3 n
    temp_expr3 2610/pow(2,14)
    expr0 "pow( ( c1 + c2 * pow((r/10000),n) ) / ( 1 + c3 * pow((r/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    expr1 "pow( ( c1 + c2 * pow((g/10000),n) ) / ( 1 + c3 * pow((g/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    expr2 "pow( ( c1 + c2 * pow((b/10000),n) ) / ( 1 + c3 * pow((b/10000),n) ), (1.7 * 2523 / pow(2,5)))"
    name Expression2
    label "LMS\nto\nL'M'S'"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 357
   }
   ColorMatrix {
    matrix {
        {0 {1-epsilon} 0}
        {3.524 -4.066708 0.542708}
        {0.199076 1.096799 -1.295875}
      }
    name ColorMatrix2
    label "L'M'S\nto\nIzazbz"
    note_font "Bitstream Vera Sans"
    xpos 148
    ypos 417
    addUserKnob {20 User}
    addUserKnob {7 epsilon}
    epsilon 3.703522621e-11
   }
   Output {
    name Output1
    xpos 148
    ypos 517
   }
  end_group
  Dot {
   name Dot2
   xpos 114
   ypos 53
  }
push $N3b1524a0
  MergeExpression {
   inputs 2
   temp_name0 Qz
   temp_expr0 "2700 * pow(Br, (1.6 * parent.F_s) / pow(parent.F_b, 0.12)) * pow(parent.F_s, 2.2) * pow(parent.F_b, 0.5) * pow(parent.F_L, 0.2)"
   temp_name1 Qzw
   temp_expr1 "2700 * pow(Ar, (1.6 * parent.F_s) / pow(parent.F_b, 0.12)) * pow(parent.F_s, 2.2) * pow(parent.F_b, 0.5) * pow(parent.F_L, 0.2)"
   temp_name2 j
   temp_expr2 100*(Qz/Qzw)
   channel0 {zcam_1d.J -zcam_1d.C -zcam_1d.h none}
   expr0 j
   channel1 {rgba.red -rgba.green -rgba.blue none}
   expr1 j
   channel2 none
   channel3 none
   name MergeExpression1
   xpos -66
   ypos 50
  }
  Output {
   name Output
   xpos -66
   ypos 117
  }
 end_group
push $N3b12e0c0
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy1
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos -159
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge4
  label "highlight de-sat"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos -135
  disable {{!parent.applyHighlightDesat}}
 }
 Dot {
  name Dot1
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos -23
 }
set N3b2141e0 [stack 0]
 Dot {
  name Dot31
  note_font "Bitstream Vera Sans"
  xpos -1004
  ypos -23
 }
set N3b218f40 [stack 0]
 Dot {
  name Dot28
  note_font "Bitstream Vera Sans"
  xpos -854
  ypos -23
 }
set N3b21de50 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle1
  label "Clear to White"
  note_font "Bitstream Vera Sans"
  xpos -736
  ypos -32
 }
 Colorspace {
  illuminant_in {{parent.illuminant_out}}
  primary_in {{parent.primary_out}}
  colorspace_out CIE-XYZ
  name Colorspace5
  label "Output White to XYZ"
  xpos -736
  ypos 4
 }
 Multiply {
  channels rgb
  value {{parent.ssts_luminance.1}}
  name Multiply22
  label "scale to SSTS\nmid luminance"
  note_font "Bitstream Vera Sans"
  xpos -736
  ypos 36
 }
 Group {
  name ZCAM_JMh_Blink2
  label "XYZ to JMh\nno drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -736
  ypos 84
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.white}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N3b26e0f0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N3b273010 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N3b273010
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N3b26e0f0
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
push $N3b21de50
 Group {
  name ZCAM_GamutBoundaryBlink1
  note_font "Bitstream Vera Sans"
  xpos -888
  ypos 10
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionJ}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
  outputCusps true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   primary_out DCI-P3
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N3b32c650 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N3b3315b0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N3b3315b0
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N3b32c650
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
 Dot {
  name Dot32
  note_font "Bitstream Vera Sans"
  xpos -854
  ypos 135
 }
set N3b388ec0 [stack 0]
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy7
  note_font "Bitstream Vera Sans"
  xpos -736
  ypos 132
 }
 Dot {
  name Dot18
  note_font "Bitstream Vera Sans"
  xpos -702
  ypos 188
 }
push $N3b388ec0
 Switch {
  inputs 2
  which {{parent.focusTarget}}
  name Switch6
  label "Cusp or SSTSmid"
  note_font "Bitstream Vera Sans"
  xpos -888
  ypos 179
 }
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply6
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -888
  ypos 215
 }
push $N3b218f40
 Multiply {
  channels rgb
  value {{1/parent.reference_luminance} 1 1 1}
  name Multiply2
  label "Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -1038
  ypos 173
 }
 MergeExpression {
  inputs 2
  temp_name0 v
  temp_expr0 Bg/Ab
  temp_name1 relThreshold
  temp_expr1 max(0,threshold*Ag/Ab)
  temp_name2 s
  temp_expr2 (limit-relThreshold)/pow(pow((1-relThreshold)/(limit-relThreshold),-power)-1,1/power)
  temp_name3 compressed
  temp_expr3 (v<relThreshold||limit<1.0001)?v:relThreshold+s*((v-relThreshold)/s)/(pow(1+pow((v-relThreshold)/s,power),1/power))
  expr0 (Br-Ar*cuspFocus)*(compressed/v)+Ar*cuspFocus
  name MergeExpression2
  label "Compress to Cusp"
  note_font "Bitstream Vera Sans"
  xpos -1038
  ypos 221
  addUserKnob {20 User}
  addUserKnob {7 threshold}
  threshold {{parent.compressionJ.0}}
  addUserKnob {7 limit R 1 10}
  limit {{parent.compressionJ.1}}
  addUserKnob {7 power R 0 3}
  power {{parent.compressionJ.2}}
  addUserKnob {7 cuspFocus R 0 2}
  cuspFocus {{parent.focusScale}}
 }
 Multiply {
  channels rgb
  value {{parent.reference_luminance} 1 1 1}
  name Multiply8
  label "De-Normalise\nLuminance"
  note_font "Bitstream Vera Sans"
  xpos -1038
  ypos 257
 }
push $N3b2141e0
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy5
  label "Apply Modified\nLightness (J)"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 257
  disable {{!parent.applyGamutMappingJ}}
 }
 Dot {
  name Dot33
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos 385
 }
set N3b40f940 [stack 0]
 Dot {
  name Dot2
  note_font "Bitstream Vera Sans"
  xpos -994
  ypos 385
 }
set N3b414830 [stack 0]
 Dot {
  name Dot23
  note_font "Bitstream Vera Sans"
  xpos -850
  ypos 385
 }
 Group {
  name ZCAM_GamutBoundaryBlink3
  note_font "Bitstream Vera Sans"
  xpos -884
  ypos 457
  addUserKnob {20 User}
  addUserKnob {7 boundaryLuminance R 0 1000}
  boundaryLuminance {{parent.ssts_luminance.2}}
  addUserKnob {41 boundaryWhite T XYZ_to_RGB.illuminant_out}
  addUserKnob {41 boundaryGamut -STARTLINE T XYZ_to_RGB.primary_out}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  viewingConditions {{parent.ZCAM_JMh_Blink1.viewingConditions}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {3 precision}
  precision {{parent.precisionM}}
  addUserKnob {6 discountIlluminant +STARTLINE}
  addUserKnob {6 outputCusps +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 275
   bdheight 249
  }
  Constant {
   inputs 0
   format "3 1 0 0 3 1 1 3x1px"
   name Constant1
   label "3x1 px"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 184
  }
  Expression {
   expr0 "x == 0 ? 1 : 0"
   expr1 "x == 1 ? 1 : 0"
   expr2 "x == 2 ? 1 : 0"
   name Expression1
   label "RGB pix"
   note_font "Bitstream Vera Sans"
   xpos 1138
   ypos 268
  }
  Colorspace {
   colorspace_in CIE-XYZ
   illuminant_out {{parent.parent.white}}
   primary_out {{parent.parent.gamut}}
   name XYZ_to_RGB
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 268
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N3b4648d0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N3b469830 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N3b469830
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N3b4648d0
  BlinkScript {
   inputs 4
   recompileCount 106
   ProgramGroup 1
   KernelDescription "2 \"Gamut_Boundary_Kernel_v02\" iterate pixelWise 72f480e3c5c39207ee6d9b62710e547a40831790c43275a43a017bc97590365a 5 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"XYZtoRGB\" Read Random \"dst\" Write Point 11 \"catType\" Int 1 AAAAAA== \"boundaryLuminance\" Float 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== \"precision\" Int 1 AAAAAA== \"outputCusp\" Int 1 AAAAAA== 11 \"catType\" 1 1 \"boundaryLuminance\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 \"precision\" 1 1 \"outputCusp\" 1 1 13 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel Gamut_Boundary_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image in ZCAM \[J, M, h, a]\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eRead, eAccessRandom, eEdgeClamped> XYZtoRGB; // RGB values of X, Y & Z to sample matrix values from\n  Image<eWrite> dst; // the output image in \[Jcusp, Mboundary, Mcusp, a]\n\n  param:\n    int catType;\n    float boundaryLuminance;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n    int precision;\n    int outputCusp;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float boundaryRGB;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    boundaryRGB = boundaryLuminance / referenceLuminance;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n  float findBoundary( float J, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB )\n  \{\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float3 JMhboundary = float3(J, 0.0f, h);\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMhboundary.y = JMhboundary.y + Mstep;\n        float3 RGBtest = vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( JMhboundary, XYZw, XYZd65 ) / referenceLuminance );\n        float minRGBtest = min(RGBtest.x, min(RGBtest.y, RGBtest.z));\n        float maxRGBtest = max(RGBtest.x, max(RGBtest.y, RGBtest.z));\n\n        if( direction ) // M is increasing\n        \{\n          if( JMhboundary.y > 1000.0f || minRGBtest < 0.0f || maxRGBtest > boundaryRGB )\n          \{\n            direction = 0;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n        else // M is decreasing\n        \{\n          if( JMhboundary.y < 0.0f || (minRGBtest >= 0.0f && maxRGBtest <= boundaryRGB ) )\n          \{\n            direction = 1;\n            Mstep = Mstep * (-0.5f);\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    return JMhboundary.y;\n\n  \}\n\n  void process()\n  \{\n\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3x3 XYZ_to_RGB;\n    for( int x = 0; x < 3; x++)\n    \{\n      SampleType(XYZtoRGB) inputXYZtoRGB = XYZtoRGB(x,0);\n      XYZ_to_RGB\[0]\[x] = inputXYZtoRGB.x;\n      XYZ_to_RGB\[1]\[x] = inputXYZtoRGB.y;\n      XYZ_to_RGB\[2]\[x] = inputXYZtoRGB.z;\n    \}\n\n    float3 JMh = float3(input.x, input.y, input.z);\n    float3 XYZw = float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z);\n    float3 XYZd65 = float3(inputD65White.x, inputD65White.y, inputD65White.z);\n\n    // find M at RGB boundary for current J & h\n\n    float Mstep = 10.0f;\n    int direction = 1;\n\n    float Mboundary = findBoundary(JMh.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n    float4 output = float4(input.x, Mboundary, input.z, input.w);\n\n\n    // find gamut cusp for current h\n\n    if( outputCusp )\n    \{\n\n      float Jstep = 10.0f;\n\n      float3 JMhcusp = float3(0.0f, 0.0f, JMh.z);\n\n      for( int i = 0; i < precision; ++i )\n      \{\n        float lastMboundary = 0.0f;\n        while( 1 )\n        \{\n          JMhcusp.x = JMhcusp.x + Jstep;\n          JMhcusp.y = findBoundary(JMhcusp.x, JMh.z, XYZw, XYZd65, XYZ_to_RGB);\n\n          if( (Jstep < 0.0f && JMhcusp.x < 0.0f) || (Jstep > 0.0f && JMhcusp.x > 1000.0f) || JMhcusp.y < lastMboundary )\n          \{\n            Jstep = Jstep * (-0.5f);\n            break;\n          \}\n\n          lastMboundary = JMhcusp.y;\n        \}\n      \}\n\n      output.x = JMhcusp.x;\n      output.z = JMhcusp.y;\n    \}\n\n      \n    dst() = output; \n    \n  \}\n\};\n"
   rebuild ""
   Gamut_Boundary_Kernel_v02_catType 4
   Gamut_Boundary_Kernel_v02_boundaryLuminance {{parent.boundaryLuminance}}
   Gamut_Boundary_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   Gamut_Boundary_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   Gamut_Boundary_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   Gamut_Boundary_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   Gamut_Boundary_Kernel_v02_F_L {{"0.171*pow(Gamut_Boundary_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*Gamut_Boundary_Kernel_v02_L_A))"}}
   Gamut_Boundary_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : Gamut_Boundary_Kernel_v02_F * (1 - (1 / 3.6) * exp((-Gamut_Boundary_Kernel_v02_L_A - 42) / 92))"}}
   Gamut_Boundary_Kernel_v02_precision {{parent.precision}}
   Gamut_Boundary_Kernel_v02_outputCusp {{parent.outputCusps}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 237
  }
  Output {
   name Output1
   xpos 828
   ypos 377
  }
 end_group
set N3b41e650 [stack 0]
 Dot {
  name Dot4
  note_font "Bitstream Vera Sans"
  xpos -850
  ypos 525
 }
push $N3b414830
push $N3b41e650
 Merge2 {
  inputs 2
  operation divide
  name Merge1
  xpos -1028
  ypos 457
 }
 Expression {
  expr0 (r<thr.r||lim.r<1.0001)?r:thr.r+s.r*((r-thr.r)/s.r)/(pow(1+pow((r-thr.r)/s.r,p),1/p))
  expr1 (g<thr.g||lim.g<1.0001)?g:thr.g+s.g*((g-thr.g)/s.g)/(pow(1+pow((g-thr.g)/s.g,p),1/p))
  expr2 (b<thr.b||lim.b<1.0001)?b:thr.b+s.b*((b-thr.b)/s.b)/(pow(1+pow((b-thr.b)/s.b,p),1/p))
  name Compress
  label Power(P)
  xpos -1028
  ypos 481
  addUserKnob {20 Params_tab l Params}
  addUserKnob {18 thr}
  thr {{parent.compressionM.0}}
  addUserKnob {6 thr_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 lim}
  lim {{parent.compressionM.1}}
  addUserKnob {6 lim_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 s}
  s {{(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)} {(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)} {(lim-thr)/pow(pow((1-thr)/(lim-thr),-p)-1,1/p)}}
  addUserKnob {6 s_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {7 p R 1 5}
  p {{parent.compressionM.2}}
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge2
  xpos -1028
  ypos 522
 }
push $N3b40f940
 ShuffleCopy {
  inputs 2
  green green
  alpha alpha2
  name ShuffleCopy2
  label "Apply Compressed\nColourfulness (M)"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 510
  disable {{!parent.applyGamutMappingM}}
 }
 Group {
  name ZCAM_JMh_Blink1
  label "JMh to XYZ"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 714
  addUserKnob {20 User}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance {{parent.reference_luminance}}
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance {{parent.background_luminance}}
  addUserKnob {4 catType l "CAT Type" M {None "XYZ Scaling" Bradford CAT02 Zhai2018 ""}}
  catType Zhai2018
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N3b53e160 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N3b543080 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N3b543080
  Colorspace {
   illuminant_in {{parent.parent.white}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N3b53e160
  BlinkScript {
   inputs 3
   recompileCount 67
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise b4a2d45f8223b30a707c942561ca9c894db336576c95ad6a60c024522a2e900c 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
   addUserKnob {20 User}
   addUserKnob {7 epsilon}
   epsilon 3.703522621e-11
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Multiply {
  channels rgb
  value {{1/parent.ssts_luminance.2}}
  name Multiply5
  label "Lum to Linear"
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 750
  disable {{Colorspace3.colorspace_out==31}}
 }
 Colorspace {
  colorspace_in CIE-XYZ
  colorspace_out st2084
  primary_out Rec.2020
  name Colorspace3
  label "XYZ to Output"
  xpos -1148
  ypos 786
 }
 Clamp {
  channels rgb
  name Clamp6
  note_font "Bitstream Vera Sans"
  xpos -1148
  ypos 818
  disable {{!parent.clamp_output}}
 }
 Dot {
  name Dot26
  note_font "Bitstream Vera Sans"
  xpos -1114
  ypos 909
 }
 Dot {
  name Dot27
  note_font "Bitstream Vera Sans"
  xpos -502
  ypos 909
 }
 Switch {
  inputs 2
  which {{parent.invert}}
  name Switch1
  note_font "Bitstream Vera Sans"
  xpos -516
  ypos 948
 }
 Output {
  name Output
  xpos -516
  ypos 1074
 }
end_group
Group {
 name Plot_ZCAM_JMh_Boundary2
 note_font "Bitstream Vera Sans"
 xpos -1911
 ypos -454
 addUserKnob {20 User}
 addUserKnob {26 input_settings_divider l "Input Settings"}
 addUserKnob {41 colorspace_in l colorspace T Colorspace3.colorspace_in}
 addUserKnob {41 illuminant_in l "" -STARTLINE T Colorspace3.illuminant_in}
 addUserKnob {41 primary_in l "" -STARTLINE T Colorspace3.primary_in}
 addUserKnob {7 inputReferenceLuminance l referenceLuminance R 0 10000}
 inputReferenceLuminance 100
 addUserKnob {26 zcam_settings_divider l "ZCAM Settings"}
 addUserKnob {41 referenceWhite T ZCAM_JMh_Blink1.referenceWhite}
 addUserKnob {41 referenceLuminance -STARTLINE T ZCAM_JMh_Blink1.referenceLuminance}
 addUserKnob {41 viewingConditions T ZCAM_JMh_Blink1.viewingConditions}
 addUserKnob {41 backgroundLuminance -STARTLINE T ZCAM_JMh_Blink1.backgroundLuminance}
 addUserKnob {41 catType l "CAT Type" T ZCAM_JMh_Blink1.catType}
 addUserKnob {41 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE T ZCAM_JMh_Blink1.discountIlluminant}
 addUserKnob {26 boundary_settings_divider l "Boundary Settings"}
 addUserKnob {41 illuminant l "boundary illuminant" T Colorspace1.illuminant_out}
 addUserKnob {41 primary -STARTLINE T Colorspace1.primary_out}
 addUserKnob {7 boundaryLuminance l luminance -STARTLINE R 0 1000}
 boundaryLuminance 1000
 addUserKnob {7 hue R 0 360}
 hue 330
 addUserKnob {7 hueTolerance -STARTLINE R 0 60}
 hueTolerance 2
 addUserKnob {26 plot_settings_divider l "Plot Settings"}
 addUserKnob {7 MRange l "M Range" R 0 100}
 MRange 80
 addUserKnob {7 luminanceRange R 0 1000}
 luminanceRange 1000
 addUserKnob {7 size R 0 10}
 size 1
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  label "Plot Input Samples"
  note_font_size 20
  xpos -278
  ypos -419
  bdwidth 658
  bdheight 596
 }
 Constant {
  inputs 0
  format "1024 1024 0 0 1024 1024 1 square_1k"
  name Constant1
  xpos -908
  ypos -266
 }
 Dot {
  name Dot3
  note_font "Bitstream Vera Sans"
  xpos -874
  ypos -179
 }
set N1a18d870 [stack 0]
 Dot {
  name Dot4
  note_font "Bitstream Vera Sans"
  xpos -1069
  ypos -179
 }
 Shuffle {
  red white
  green white
  blue white
  alpha white
  name Shuffle4
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1103
  ypos -104
 }
 Multiply {
  channels rgb
  value {{parent.luminanceRange}}
  name Multiply8
  note_font "Bitstream Vera Sans"
  xpos -1103
  ypos -68
 }
 Group {
  name ZCAM_JMh_Blink5
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -1103
  ypos -37
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.referenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1a1ca310 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1a1cf230 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1a1cf230
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1a1ca310
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Shuffle {
  green white
  blue white
  alpha white
  name Shuffle5
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -1103
  ypos 2
 }
push $N1a18d870
 Expression {
  temp_name0 vx
  temp_expr0 x/(input.width-1)
  temp_name1 vy
  temp_expr1 y/(input.height-1)
  expr0 vy
  expr1 vx
  expr2 1
  expr3 0
  name Expression1
  label "Generate Ramps"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -147
 }
 Multiply {
  channels rgb
  value {1 {parent.MRange} {parent.hue} 1}
  name Multiply1
  label "Scale M & h"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -49
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge4
  label "scale J"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 2
 }
 Dot {
  name Dot2
  note_font "Bitstream Vera Sans"
  xpos -874
  ypos 54
 }
set N1a284630 [stack 0]
 Group {
  name ZCAM_JMh_Blink6
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 87
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.referenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1a29f4a0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1a2a43f0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1a2a43f0
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1a29f4a0
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Multiply {
  channels rgb
  value {{1/parent.boundaryLuminance}}
  name Multiply2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 132
 }
 Colorspace {
  colorspace_in CIE-XYZ
  primary_out DCI-P3
  name Colorspace1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 188
 }
 Expression {
  temp_expr0 parent.size
  temp_name1 inr
  temp_expr1 "r <= 0 ? 0 : r > 1 ? 0 : 1"
  temp_name2 ing
  temp_expr2 "g <=0 ? 0 : g > 1 ? 0 : 1"
  temp_name3 inb
  temp_expr3 "b <= 0 ? 0 : b > 1 ? 0 : 1"
  expr3 "inr * ing * inb"
  name Expression2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 240
 }
set N1a33bf90 [stack 0]
 EdgeDetectWrapper {
  edgedetector simple
  channels alpha
  erodesize {{-parent.size}}
  blurquality 0
  name EdgeDetect1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 659
 }
push $N1a33bf90
push $N1a284630
 Dot {
  name Dot1
  note_font "Bitstream Vera Sans"
  xpos -674
  ypos 54
 }
 ShuffleCopy {
  inputs 2
  name ShuffleCopy1
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 240
 }
 Premult {
  channels {rgba.red rgba.green -rgba.blue none}
  name Premult1
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 283
 }
set N1a36e4d0 [stack 0]
 Dilate {
  size {0 {input.height*2}}
  name Dilate3
  note_font "Bitstream Vera Sans"
  xpos -488
  ypos 277
 }
 Expression {
  expr0 r*g
  name Expression3
  note_font "Bitstream Vera Sans"
  xpos -488
  ypos 363
 }
push $N1a36e4d0
 Dilate {
  channels {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  size {{input.width*2} 0}
  name Dilate1
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 319
 }
 Dilate {
  channels {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  size {0 {input.height*2}}
  name Dilate2
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 403
 }
set N1a39ba00 [stack 0]
 Shuffle {
  red green
  blue green
  name Shuffle1
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -598
  ypos 397
 }
 Merge2 {
  inputs 2
  operation divide
  name Merge1
  note_font "Bitstream Vera Sans"
  xpos -488
  ypos 403
 }
 Dilate {
  size {{input.width*2} 0}
  name Dilate5
  note_font "Bitstream Vera Sans"
  xpos -488
  ypos 443
 }
push $N1a39ba00
 ShuffleCopy {
  inputs 2
  red red
  name ShuffleCopy2
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 449
 }
 Reformat {
  type "to box"
  box_width 2
  box_height 2
  resize none
  filter Impulse
  name Reformat1
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 506
 }
 Group {
  name ZCAM_JMh_Blink4
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 530
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.referenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
  invert true
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1a4099a0 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1a40e8c0 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1a40e8c0
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1a4099a0
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Reformat {
  type "to box"
  box_width {{input.input.input.width}}
  box_height {{input.input.input.height}}
  box_fixed true
  resize distort
  filter Impulse
  name Reformat2
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 566
 }
 Multiply {
  value {{1/parent.boundaryLuminance}}
  name Multiply3
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 654
 }
 Colorspace {
  colorspace_in CIE-XYZ
  name Colorspace2
  note_font "Bitstream Vera Sans"
  xpos -708
  ypos 708
 }
 ShuffleCopy {
  inputs 2
  name ShuffleCopy3
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 708
 }
 Premult {
  name Premult2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 774
 }
 Input {
  inputs 0
  name Input
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -301
 }
 Colorspace {
  colorspace_in st2084
  primary_in Rec.2020
  colorspace_out CIE-XYZ
  name Colorspace3
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -220
 }
set N1a4d38f0 [stack 0]
 Multiply {
  channels rgb
  value {{parent.inputReferenceLuminance}}
  name Multiply5
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -194
  disable {{Colorspace3.colorspace_in==31}}
 }
 Group {
  name ZCAM_JMh_Blink1
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -145
  addUserKnob {20 User}
  addUserKnob {41 referenceWhite T RefWhite.illuminant_in}
  addUserKnob {7 referenceLuminance -STARTLINE R 0 1000}
  referenceLuminance 100
  addUserKnob {4 viewingConditions M {dark dim average}}
  addUserKnob {7 backgroundLuminance -STARTLINE R 0 100}
  backgroundLuminance 10
  addUserKnob {4 catType l "CAT Type" M {None "XYZ Scaling" Bradford CAT02 Zhai2018}}
  catType Zhai2018
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1a50db70 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1a512a90 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1a512a90
  Colorspace {
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1a50db70
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   selected true
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Expression {
  temp_name0 hue
  temp_expr0 b
  temp_name1 hueSlice
  temp_expr1 "(parent.hue < 0 ? parent.hue + 360 * ceil(abs(parent.hue)/360) : parent.hue)%360"
  temp_name2 visible
  temp_expr2 "hue >= hueSlice-parent.hueTolerance ? hue <=  hueSlice+parent.hueTolerance ? 1 : hue-360 >  hueSlice-parent.hueTolerance ? 1 : 0  : 0"
  expr0 r
  expr1 "visible ? g : 0"
  expr2 "visible ? r : 0"
  channel3 alpha
  expr3 visible
  name Expression4
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -90
 }
set N1a585fd0 [stack 0]
 Multiply {
  channels rgb
  value {1 {1/parent.MRange} 1 1}
  name Multiply4
  label "scale M"
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos -14
 }
push $N1a585fd0
 Shuffle {
  red white
  green white
  blue white
  alpha white
  name Shuffle2
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -189
  ypos -96
 }
 Multiply {
  channels rgb
  value {{parent.luminanceRange}}
  name Multiply6
  note_font "Bitstream Vera Sans"
  xpos -189
  ypos -60
 }
 Group {
  name ZCAM_JMh_Blink3
  label "no drop-downs"
  note_font "Bitstream Vera Sans"
  xpos -189
  ypos -29
  addUserKnob {20 User}
  addUserKnob {3 referenceWhite}
  referenceWhite {{parent.referenceWhite}}
  addUserKnob {3 viewingConditions}
  viewingConditions {{parent.viewingConditions}}
  addUserKnob {7 referenceLuminance R 0 1000}
  referenceLuminance {{parent.referenceLuminance}}
  addUserKnob {7 backgroundLuminance R 0 100}
  backgroundLuminance {{parent.backgroundLuminance}}
  addUserKnob {3 catType}
  catType {{parent.catType}}
  addUserKnob {6 discountIlluminant l "discountIlluminant (Zhai2018 only)" -STARTLINE}
  discountIlluminant {{parent.discountIlluminant}}
  addUserKnob {6 invert +STARTLINE}
 }
  BackdropNode {
   inputs 0
   name BackdropNode1
   label "Helper Nodes"
   note_font "Bitstream Vera Sans"
   note_font_size 20
   xpos 991
   ypos 100
   bdwidth 146
   bdheight 250
  }
  Input {
   inputs 0
   name Input1
   xpos 828
   ypos 71
  }
  Dot {
   name Dot1
   note_font "Bitstream Vera Sans"
   xpos 862
   ypos 153
  }
set N1a5d3440 [stack 0]
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name Shuffle2
   label "\[value in]-->\[value out]"
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 144
  }
set N1a5d8360 [stack 0]
  Colorspace {
   colorspace_out CIE-XYZ
   name D65White
   note_font "Bitstream Vera Sans"
   xpos 1015
   ypos 243
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{colormatrix.0+colormatrix.1+colormatrix.2} {colormatrix.3+colormatrix.4+colormatrix.5} {colormatrix.6+colormatrix.7+colormatrix.8}}
  }
push $N1a5d8360
  Colorspace {
   illuminant_in {{parent.referenceWhite}}
   colorspace_out CIE-XYZ
   name RefWhite
   note_font "Bitstream Vera Sans"
   selected true
   xpos 1015
   ypos 216
   addUserKnob {20 User}
   addUserKnob {13 value}
   value {{"\[python nuke.thisNode().knob('colormatrix').getValue(0)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(1)\\ +\\ nuke.thisNode().knob('colormatrix').getValue(2)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(3) + nuke.thisNode().knob('colormatrix').getValue(4) + nuke.thisNode().knob('colormatrix').getValue(5)]"} {"\[python nuke.thisNode().knob('colormatrix').getValue(6) + nuke.thisNode().knob('colormatrix').getValue(7) + nuke.thisNode().knob('colormatrix').getValue(8)]"}}
  }
push $N1a5d3440
  BlinkScript {
   inputs 3
   recompileCount 77
   ProgramGroup 1
   KernelDescription "2 \"ZCAM_JMh_Kernel_v02\" iterate pixelWise ceee120ed5b8959bf397eeb05de13fd5dbac868677e435287c542695cb78e73f 4 \"src\" Read Point \"refWhite\" Read Point \"d65White\" Read Point \"dst\" Write Point 9 \"direction\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"F\" Float 1 AAAAAA== \"F_s\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"F_b\" Float 1 AAAAAA== \"F_L\" Float 1 AAAAAA== \"adaptDegree\" Float 1 AAAAAA== 9 \"direction\" 1 1 \"catType\" 1 1 \"referenceLuminance\" 1 1 \"F\" 1 1 \"F_s\" 1 1 \"L_A\" 1 1 \"F_b\" 1 1 \"F_L\" 1 1 \"adaptDegree\" 1 1 12 \"cb\" Float 1 1 AAAAAA== \"cg\" Float 1 1 AAAAAA== \"c1\" Float 1 1 AAAAAA== \"c2\" Float 1 1 AAAAAA== \"c3\" Float 1 1 AAAAAA== \"eta\" Float 1 1 AAAAAA== \"rho\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "\nkernel ZCAM_JMh_Kernel_v02 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> refWhite; // reference white image\n  Image<eRead, eAccessPoint, eEdgeClamped> d65White; // D65 white image\n  Image<eWrite> dst; // the output image\n\n  param:\n    int direction;\n    int catType;\n    float referenceLuminance;\n    float F;\n    float F_s;\n    float L_A;\n    float F_b;\n    float F_L;\n    float adaptDegree;\n\n  local:\n    float cb;\n    float cg;\n    float c1;\n    float c2;\n    float c3;\n    float eta;\n    float rho;\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n\n  void define()\n  \{\n\n  \}\n\n\n  void init()\n  \{\n    cb  = 1.15f;\n    cg  = 0.66f;\n    c1  = 3424.0f / pow(2.0f,12.0f);\n    c2  = 2413.0f / pow(2.0f, 7.0f);\n    c3  = 2392.0f / pow(2.0f, 7.0f);\n    eta = 2610.0f / pow(2.0f,14.0f);\n    rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n  \}\n\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = cb * XYZD65.x - (cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = cg * XYZD65.y - (cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( c1 + c2 * spow((LMS.x/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.x/10000.0f),eta) ), rho);\n    LMSp.y = spow( ( c1 + c2 * spow((LMS.y/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.y/10000.0f),eta) ), rho);\n    LMSp.z = spow( ( c1 + c2 * spow((LMS.z/10000.0f),eta) ) / ( 1.0f + c3 * spow((LMS.z/10000.0f),eta) ), rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz )\n  \{\n    float3 JMh = 0.0f;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(F_L, 0.2f)) / (pow(F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz)\n  \{\n    float Qzm = pow(F_s, 2.2f) * pow(F_b, 0.5f) * pow(F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * F_s) / pow(F_b, 0.12f)) * Qzm;\n    float Izp = pow(F_b, 0.12f) / (1.6f * F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((c1-spow(LMSp.x,1.0f/rho)) / (c3*spow(LMSp.x,1.0f/rho)-c2),1.0f/eta);\n    LMS.y = 10000.0f*spow((c1-spow(LMSp.y,1.0f/rho)) / (c3*spow(LMSp.y,1.0f/rho)-c2),1.0f/eta);\n    LMS.z = 10000.0f*spow((c1-spow(LMSp.z,1.0f/rho)) / (c3*spow(LMSp.z,1.0f/rho)-c2),1.0f/eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(cb-1.0f)*XYZpD65.z)/cb;\n    XYZD65.y = (XYZpD65.y+(cg-1.0f)*XYZD65.x)/cg;\n    return XYZD65;\n  \}\n\n\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType)), refWhiteIzazbz.x);\n  \}\n\n\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x)), d65White, refWhite, catType);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) input = src();\n    SampleType(refWhite) inputRefWhite = refWhite();\n    SampleType(d65White) inputD65White = d65White();\n\n    float3 output = 0.0f;\n\n    if( direction == 0 )\n    \{\n      output = XYZ_to_ZCAM_JMh(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n    else\n    \{\n       output = ZCAM_JMh_to_XYZ(float3(input.x, input.y, input.z), float3(inputRefWhite.x, inputRefWhite.y, inputRefWhite.z), float3(inputD65White.x, inputD65White.y, inputD65White.z));\n    \}\n\n    dst() = float4(output.x, output.y, output.z, input.w);\n  \}\n\};\n"
   rebuild ""
   ZCAM_JMh_Kernel_v02_direction {{parent.invert}}
   ZCAM_JMh_Kernel_v02_catType {{parent.catType}}
   ZCAM_JMh_Kernel_v02_referenceLuminance {{parent.referenceLuminance}}
   ZCAM_JMh_Kernel_v02_F {{"\[python (0.8, 0.9, 1.0)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_F_s {{"\[python (0.525, 0.59, 0.69)\\\[\[numvalue viewingConditions]\\]]"}}
   ZCAM_JMh_Kernel_v02_L_A {{"referenceLuminance * backgroundLuminance / 100"}}
   ZCAM_JMh_Kernel_v02_F_b {{sqrt(backgroundLuminance/referenceLuminance)}}
   ZCAM_JMh_Kernel_v02_F_L {{"0.171*pow(ZCAM_JMh_Kernel_v02_L_A, 1/3) * (1-exp(-48/9*ZCAM_JMh_Kernel_v02_L_A))"}}
   ZCAM_JMh_Kernel_v02_adaptDegree {{"parent.discountIlluminant ? 1 : ZCAM_JMh_Kernel_v02_F * (1 - (1 / 3.6) * exp((-ZCAM_JMh_Kernel_v02_L_A - 42) / 92))"}}
   rebuild_finalise ""
   name BlinkScript1
   note_font "Bitstream Vera Sans"
   xpos 828
   ypos 221
  }
  Output {
   name Output1
   xpos 828
   ypos 335
  }
 end_group
 Shuffle {
  red white
  green white
  blue red
  alpha white
  name Shuffle3
  label "\[value in]-->\[value out]"
  note_font "Bitstream Vera Sans"
  xpos -189
  ypos 22
 }
 Merge2 {
  inputs 2
  operation divide
  name Merge3
  label "scale J"
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos 22
 }
push $N1a585fd0
push $N1a4d38f0
 Colorspace {
  colorspace_in CIE-XYZ
  colorspace_out BT1886
  name Colorspace4
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos -220
 }
 Multiply {
  channels rgb
  value 0.1
  name Multiply9
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos -196
  disable {{Colorspace3.colorspace_in!=31}}
 }
 Multiply {
  value {{1-Add3.value}}
  name Multiply7
  note_font "Bitstream Vera Sans"
  selected true
  xpos 169
  ypos -162
 }
 Add {
  value 0.1
  name Add3
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos -126
 }
 ShuffleCopy {
  inputs 2
  name ShuffleCopy4
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos -90
 }
 Premult {
  name Premult3
  note_font "Bitstream Vera Sans"
  xpos 169
  ypos 77
 }
 BlinkScript {
  inputs 2
  recompileCount 4
  ProgramGroup 1
  KernelDescription "2 \"plot_cie_xy\" iterate pixelWise 4f09b488f640fe57a9b92d835cc81424078e447e427d9f43fb8d958e7333c795 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 4 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"bottom_margin\" Float 1 AAAAAA== \"process_input\" Bool 1 AA== 4 \"padding\" 1 1 \"left_margin\" 1 1 \"bottom_margin\" 1 1 \"process_input\" 1 1 3 \"outsize\" Float 1 1 AAAAAA== \"offsetX\" Float 1 1 AAAAAA== \"offsetY\" Float 1 1 AAAAAA=="
  kernelSource "kernel plot_cie_xy : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float bottom_margin;\n  bool process_input;\n\n\nlocal:\n  float outsize;\n  float offsetX;\n  float offsetY;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = dst.bounds.height()/padding;\n    // xy offset for margin on lower left corner\n    offsetX = left_margin;\n    offsetY = bottom_margin;\n  \}\n\n  void process(int2 pos) \{\n    // All the work will be done in the first pixel of the iteration. Essentially a single thread.\n    if ( pos.x > 1 || pos.y > 1) \{ return; \}\n    // Loop over all pixels in input Yxy\n    if (process_input) \{\n      for ( int j = Yxy.bounds.y1; j < Yxy.bounds.y2; j++) \{\n        for ( int i = Yxy.bounds.x1; i < Yxy.bounds.x2; i++) \{\n          // sample Yxy pixel at position i, j\n          float2 xy = float2(Yxy(i, j, 1), Yxy(i, j, 2));\n          // don't process black pixels\n          if( xy.x == 0.0f && xy.y == 0.0f) \{ continue; \}\n          // calculate output position: xy chromaticity coordinates at centered output pixel position\n          float2 out_pos = float2(xy.x * outsize + offsetX, xy.y * outsize + offsetY);\n          // Write color value to xy sample position in dst\n          if ( dst.bounds.inside(out_pos.x, out_pos.y)) \{ dst(out_pos.x, out_pos.y) = col(i, j); \}\n        \}\n      \}\n    \}\n  \}\n\};"
  vectorize false
  rebuild ""
  plot_cie_xy_padding 1
  plot_cie_xy_process_input true
  format "1024 1024 0 0 1024 1024 1 square_1k"
  specifiedFormat true
  rebuild_finalise ""
  name Plot_Input1
  xpos 4
  ypos 73
  cached true
 }
 Dilate {
  size {{parent.size}}
  name Dilate4
  note_font "Bitstream Vera Sans"
  xpos 4
  ypos 123
 }
 Dot {
  name Dot5
  note_font "Bitstream Vera Sans"
  xpos 52
  ypos 818
 }
 Merge2 {
  inputs 2
  name Merge2
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos 815
 }
 Output {
  name Output1
  xpos -908
  ypos 857
 }
end_group
