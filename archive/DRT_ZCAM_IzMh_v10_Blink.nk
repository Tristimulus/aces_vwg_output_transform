#! /lucas/ilm/sww/rhel7/tools/bundles/versions/Nuke12.0v8#1.0/libnuke-12.0.8.so -nx
version 12.0 v8
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="0" w="2559" h="1378" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1795" stretch="1"/>
            <splitter orientation="2">
                <split size="659"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="673"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="716"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /dept/clrimg/matthias/ampas/output_vwg/nuke/DRT_ZCAM_IzMh_v10_Blink.nk
 frame 2
 last_frame 65
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 OCIO_config custom
 customOCIOConfigPath /Users/afry/Documents/GitHub/OpenColorIO-Configs/aces_1.2/config.ocio
 defaultViewerLUT "OCIO LUTs"
 workingSpaceLUT linear
 monitorLut sRGB
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
 addUserKnob {20 GMS l "Global MotionBlur Controls"}
 addUserKnob {20 TGC l "Transform Global Control" n 1}
 addUserKnob {7 motionblur l "motion blur" R 0 4}
 addUserKnob {7 shutter R 0 4}
 addUserKnob {1 t_ind l status:}
 addUserKnob {22 batchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.tc_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 batchoninteractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.tc_batch_on_interactive_off()"}
 addUserKnob {22 batchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.tc_batch_off_interactive_off()"}
 addUserKnob {7 msamplert +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {20 RRGC l "Roto Render Global Control" n 1}
 addUserKnob {6 motionBlur l "motion blur" t "Toggle motionBlurAllCrvs on/off" +STARTLINE}
 addUserKnob {6 motionBlurAllCrvs l "motion blur all crvs" t "Toggle motionBlurAllCrvs on/off" +STARTLINE}
 addUserKnob {7 shutterAngle l "shutter angle" R 0 360}
 addUserKnob {7 shutterStart l "shutter start" R -180 180}
 addUserKnob {7 motionBlurSteps l "motion blur steps" R 0 2}
 addUserKnob {1 rr_ind l status:}
 addUserKnob {22 rrbatchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rr_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 rrbatchointeractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rr_batch_on_interactive_off()"}
 addUserKnob {22 rrbatchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rr_batch_off_interactive_off()"}
 addUserKnob {20 endGroup_2 l endGroup n -1}
 addUserKnob {20 C3dGC l "Card3D Global Control" n 1}
 addUserKnob {7 motionblurc3d l "motion blur" R 0 4}
 addUserKnob {7 shutterc3d l shutter R 0 2}
 addUserKnob {1 c3d_ind l status:}
 addUserKnob {22 c3dbatchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.c3d_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 crdbatchoninteractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.c3d_batch_on_interactive_off()"}
 addUserKnob {22 c3dbatchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.c3d_batch_off_interactive_off()"}
 addUserKnob {7 msamplerc3d +HIDDEN}
 addUserKnob {20 endGroup_3 l endGroup n -1}
 addUserKnob {20 sr l "Scanline Render Global Control" n 1}
 addUserKnob {7 prescan_samples l samples R 0 50}
 addUserKnob {7 batch_samples l "batch samples" R 0 50}
 addUserKnob {7 scan_shutter l shutter}
 addUserKnob {1 sr_ind l status:}
 addUserKnob {22 srbatchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.sr_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 srbatchoninteractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.sr_batch_on_interactive_off()"}
 addUserKnob {22 srbatchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.sr_batch_off_interactive_off()"}
 addUserKnob {7 scan_sampler +HIDDEN R 0 50}
 addUserKnob {7 scan_samples +HIDDEN R 0 50}
 addUserKnob {7 batch_sampler +HIDDEN R 0 10}
 addUserKnob {20 endGroup_4 l endGroup n -1}
 addUserKnob {20 rn l "Roto Node Global Control" n 1}
 addUserKnob {6 rotoMotionBlur_on l "motion blur" t "toggle motionBlur button on Roto nodes on or off\n" +STARTLINE}
 addUserKnob {7 rotoMotionBlur_samples l "motion blur samples" t "Sets the number of motion blur samples" R 0 4}
 addUserKnob {7 rotoMotionBlur_shutter l "motion blur shutter" t "This sets how long the shutter should be open. The value is in frames, so 0.5 is half a frame" R 0 2}
 addUserKnob {4 rotoShutterOffsetType l "shutter offset type" t "The value of this controls how the shutter behaves with respect to the current frame value" M {centred start end custom}}
 addUserKnob {7 rotoShutterOffset l "shutter offset" t "If the 'shutter offset type' is set to 'custom', this parameter is used to set the time the shutter opens by adding it to the current frame. \nValues are in frames, so -0.5 would open the shutter half a frame before the current frame" R -1 1}
 addUserKnob {1 rn_ind l status:}
 addUserKnob {22 rnbatchoninteractiveon l " Interactive ON / Batch ON " T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rn_batch_on_interactive_on()" +STARTLINE}
 addUserKnob {22 rnbatchointeractiveoff l " Interactive OFF / Batch ON " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rn_batch_on_interactive_off()"}
 addUserKnob {22 rnbatchoffinteractiveoff l " Interactive OFF / Batch OFF " -STARTLINE T "import comp_motion_blur.callbacks; comp_motion_blur.callbacks.rn_batch_off_interactive_off()"}
 addUserKnob {20 endGroup_5 l endGroup n -1}
}
BackdropNode {
 inputs 0
 name BackdropNode1
 tile_color 0x696969ff
 label "DRT_ ZCAM_IzMh_v10_Blink"
 note_font_size 20
 xpos -1640
 ypos -694
 bdwidth 573
 bdheight 316
}
BackdropNode {
 inputs 0
 name BackdropNode2
 label "HDR Settings"
 note_font_size 16
 xpos -1334
 ypos -645
 bdwidth 260
 bdheight 250
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode3
 label "SDR Settings"
 note_font_size 16
 xpos -1626
 ypos -647
 bdwidth 260
 bdheight 250
 z_order 1
}
Group {
 inputs 0
 name DRT_ZCAM_IzMh_v10_Blink2
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]"
 note_font "Bitstream Vera Sans"
 xpos -1235
 ypos -545
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 addUserKnob {4 cat_type l "CAT Type" t "the chromatic adaptation transform to use for converting between white points" M {None "XYZ Scaling" Bradford CAT02 Zhai2018 ""}}
 cat_type Zhai2018
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {6 apply_ssts l "apply SSTS" t "toggle the SingleStageToneScale transform" +STARTLINE}
 apply_ssts true
 addUserKnob {13 ssts_luminance l "SSTS luminance" t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 1000}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {6 apply_highlight_desat l "apply highlight desat" t "toggle de-saturating the highlights above SSTS mid luminance based on how much the SSTS has compressed them" +STARTLINE}
 apply_highlight_desat true
 addUserKnob {7 desat_highlights l "desat highlights" t "the amount of desaturation applied to the highlights" R 0 5}
 desat_highlights 3.5
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 apply_gamut_compression l "apply gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l primaries t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI ""}}
 primaries_limit P3-D65
 addUserKnob {6 discount_illuminant l "discount illuminant (Zhai2018 only)" t "disable the degree of adaptation model for the Zhai2018 CAT\nthis is only effective if the limiting primaries do not use a D65 white point" -STARTLINE}
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.5
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "gamut cusp (0) to SSTS mid (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "the distance from the achromatic axis of the focal point of the compression where 0.0 is at the achromatic axis and 1.0 the distance of the gamut cusp at the given hue but on the opposite side of the achomatic axis" R 0 2}
 focus_distance 0.5
 addUserKnob {26 focus_depth_label l " " -STARTLINE T "achromatic (0) to cusp opposite (1)"}
 addUserKnob {13 compression_params l compression t "the threshold, limit and power parameters for the PowerP compression function\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.2 1.2}
 addUserKnob {26 compression_params_label l " " -STARTLINE T "threshold / limit / power"}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.25
 addUserKnob {3 solve_precision l "solve precision" t "the number of iterations used for finding the gamut boundary using the interval bisection method"}
 solve_precision 10
 addUserKnob {3 inverse_solver_iterations l "inverse solver iterations" t "the number of iterations used for finding the original J & M values when applying the inverse gamut compression"}
 inverse_solver_iterations 10
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 ""}}
 encoding_out ST2084
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 primaries_out Rec.2020-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -294
 }
 BlinkScript {
  recompileCount 129
  ProgramGroup 1
  KernelDescription "2 \"DRT_ZCAM_v10_Kernel\" iterate pixelWise 1fceba9d8fc7d80461dce7173d563f0516f7ee3a72e55c23f8125f688a68235d 2 \"src\" Read Point \"dst\" Write Point 23 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"discountIlluminant\" Bool 1 AA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"applySsts\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyHighlightDesat\" Bool 1 AA== \"desatHighlights\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"boundarySolvePrecision\" Int 1 AAAAAA== \"inverseSolverIterations\" Int 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"invert\" Bool 1 AA== 23 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"catType\" 1 1 \"discountIlluminant\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"applySsts\" 1 1 \"sstsLuminance\" 3 1 \"applyHighlightDesat\" 1 1 \"desatHighlights\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 3 1 \"smoothCusps\" 1 1 \"boundarySolvePrecision\" 1 1 \"inverseSolverIterations\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"invert\" 1 1 72 \"HALF_MIN\" Float 1 1 AAAAAA== \"HALF_MAX\" Float 1 1 AAAAAA== \"zcam_L_A\" Float 1 1 AAAAAA== \"zcam_F_b\" Float 1 1 AAAAAA== \"zcam_F_L\" Float 1 1 AAAAAA== \"zcam_cb\" Float 1 1 AAAAAA== \"zcam_cg\" Float 1 1 AAAAAA== \"zcam_c1\" Float 1 1 AAAAAA== \"zcam_c2\" Float 1 1 AAAAAA== \"zcam_c3\" Float 1 1 AAAAAA== \"zcam_eta\" Float 1 1 AAAAAA== \"zcam_rho\" Float 1 1 AAAAAA== \"zcam_luminance_shift\" Float 1 1 AAAAAA== \"zcam_viewing_conditions_coeff\" Float 1 1 AAAAAA== \"cat_adaptDegree\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"ssts_min_stop_sdr\" Float 1 1 AAAAAA== \"ssts_max_stop_sdr\" Float 1 1 AAAAAA== \"ssts_min_stop_rrt\" Float 1 1 AAAAAA== \"ssts_max_stop_rrt\" Float 1 1 AAAAAA== \"ssts_min_lum_sdr\" Float 1 1 AAAAAA== \"ssts_max_lum_sdr\" Float 1 1 AAAAAA== \"ssts_min_lum_rrt\" Float 1 1 AAAAAA== \"ssts_max_lum_rrt\" Float 1 1 AAAAAA== \"ssts_n_knots_low\" Int 1 1 AAAAAA== \"ssts_n_knots_high\" Int 1 1 AAAAAA== \"ssts_m1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_minTable\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_maxTable\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_bendsLow\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_bendsHigh\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_min_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_mid_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_max_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_knotIncLow\" Float 1 1 AAAAAA== \"ssts_knotIncHigh\" Float 1 1 AAAAAA== \"ssts_pctLow\" Float 1 1 AAAAAA== \"ssts_pctHigh\" Float 1 1 AAAAAA== \"ssts_coefsLow\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_coefsHigh\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_expShift\" Float 1 1 AAAAAA== \"ssts_paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"limitMmax\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"focusDistanceClamped\" Float 1 1 AAAAAA=="
  kernelSource "\nkernel DRT_ZCAM_v10_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    //\n    // ZCAM Paramters\n    //\n\n    // Chomatic Adaptation Transform to Use\n    // 0: None\n    // 1: XYZ Scaling\n    // 2: Bradford\n    // 3: CAT02\n    // 4: Zhai2018 (two-step)\n    int catType;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n\n    //\n    // SSTS Parameters\n    //\n\n    // Toggle SSTS Tone Mapping\n    bool applySsts;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle Highlight De-Saturation\n    bool applyHighlightDesat;\n\n    // Scale the De-Saturation Applied to the Highlights\n    float desatHighlights;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // the distance of the compression focal point\n    // from the achromatic axis\n    // normalised to the distance of the gamut cusp\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / Limit / Power\n    float3 compressionFuncParams;\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    // When solving for the target gamut boundary\n    // how many search interval halving steps to perform\n    int boundarySolvePrecision;\n\n    // Number of iterations to converge on the uncompressed J value \n    // Because of the compression focus point changes depending on the J value of the uncompressed sample\n    // we cannot perfectly invert it since the original J value has now been changed by the forward compression\n    // we can converge on a reasonable approximation of the original J value by iterating the inverse compression\n    // although this is quite an expensive operation\n    int inverseSolverIterations;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n\n  local:\n\n    // constants\n    float HALF_MIN;\n    float HALF_MAX;\n\n    // ZCAM vars\n    float zcam_L_A;\n    float zcam_F_b;\n    float zcam_F_L;\n    float zcam_cb;\n    float zcam_cg;\n    float zcam_c1;\n    float zcam_c2;\n    float zcam_c3;\n    float zcam_eta;\n    float zcam_rho;\n    float zcam_luminance_shift;\n    float zcam_viewing_conditions_coeff;\n\n    // CAT vars\n    float cat_adaptDegree;\n\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // SSTS constants\n    float ssts_min_stop_sdr;\n    float ssts_max_stop_sdr;\n    float ssts_min_stop_rrt;\n    float ssts_max_stop_rrt;\n    float ssts_min_lum_sdr;\n    float ssts_max_lum_sdr;\n    float ssts_min_lum_rrt;\n    float ssts_max_lum_rrt;\n    int ssts_n_knots_low;\n    int ssts_n_knots_high;\n    float3x3 ssts_m1;\n\n    // SSTS tables\n    // using the float4 type to store the two 2D vectors\n    // because Blink does not support generic array assignments\n    float4 ssts_minTable;\n    float4 ssts_maxTable;\n    float4 ssts_bendsLow;\n    float4 ssts_bendsHigh;\n\n    // SSTS parameters\n    float3 ssts_min_pt;\n    float3 ssts_mid_pt;\n    float3 ssts_max_pt;\n    float ssts_knotIncLow;\n    float ssts_knotIncHigh;\n    float ssts_pctLow;\n    float ssts_pctHigh;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n    float3x3 ssts_coefsLow;\n    float3x3 ssts_coefsHigh;\n\n    float ssts_expShift;\n    float3 ssts_paramMin;\n    float3 ssts_paramMid;\n    float3 ssts_paramMax;\n\n\n    // matrix vars\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 refWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // the maximum colorfulness value of the limiting gamut\n    float limitMmax;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given ZCAM hue (h) value \n    // one must search the table entries for the mathcing entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since tempoary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n\n    // local version of the public focusDistance parameter\n    // this one will be clamped to a value > 0.0\n    float focusDistanceClamped;\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // get the y value of f(x) where the fuction is defined as a line between two points\n  // the two points as passed as an array \[a.x, a.y, b.x, b.y]\n  float lerp1D( float4 table, float x)\n  \{\n    float m = (table.w-table.y) / (table.z-table.x);\n    float c = table.y - (m*table.x);\n    float y = x*m+c;\n    return y;\n  \}\n\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially retured -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // Two-Stage chromatic adaptation transforms as proposed by  Zhai, Q., & Luo, M. R. (2018)\n  // https://opg.optica.org/oe/fulltext.cfm?uri=oe-26-6-7724\n  // https://github.com/colour-science/colour/blob/e5fa0790adcc3e5df5fa42ddf2bb75214c8cf59c/colour/adaptation/zhai2018.py\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n  // apply chromatic adaptation transform to 'XYZ' from 'XYZ_ws' to 'XYZ_wd' white points\n  // 'type' selects the cone fundamentals matrix (exept for Zhai2018 which uses a 2-stage tranforms based on CATO2 fundamentals)\n  // 'adaptDegree' sets the degree of adaptation for the Zhai2018 model\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type, float adaptDegree )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  // convert XYZ tristimulus values to the ZCAM intermediate Izazbz colorspace\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = zcam_cb * XYZD65.x - (zcam_cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = zcam_cg * XYZD65.y - (zcam_cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( zcam_c1 + zcam_c2 * spow((LMS.x/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.x/10000.0f),zcam_eta) ), zcam_rho);\n    LMSp.y = spow( ( zcam_c1 + zcam_c2 * spow((LMS.y/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.y/10000.0f),zcam_eta) ), zcam_rho);\n    LMSp.z = spow( ( zcam_c1 + zcam_c2 * spow((LMS.z/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.z/10000.0f),zcam_eta) ), zcam_rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  // convert the ZCAM intermediate Izazbz colorspace to XYZ tristimulus values\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((zcam_c1-spow(LMSp.x,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.x,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    LMS.y = 10000.0f*spow((zcam_c1-spow(LMSp.y,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.y,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    LMS.z = 10000.0f*spow((zcam_c1-spow(LMSp.z,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.z,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(zcam_cb-1.0f)*XYZpD65.z)/zcam_cb;\n    XYZD65.y = (XYZpD65.y+(zcam_cg-1.0f)*XYZD65.x)/zcam_cg;\n    return XYZD65;\n  \}\n\n\n  // convert the ZCAM intermediate Izazbz colorspace to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs the Iz values of the reference white and the viewing conditions parameters\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz, int viewingConditions )\n  \{\n    float3 JMh = 0.0f;\n    float zcam_F_s = zcam_viewing_conditions_coeff;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(zcam_F_L, 0.2f)) / (pow(zcam_F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  // convert the ZCAM J (lightness), M (colorfulness) and h (hue) correlates to the ZCAM intermediate Izazbz colorspace\n  // needs the Iz values of the reference white and the viewing conditions parameters\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz, int viewingConditions )\n  \{\n    float zcam_F_s = zcam_viewing_conditions_coeff;\n    float Qzm = pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * Qzm;\n    float Izp = pow(zcam_F_b, 0.12f) / (1.6f * zcam_F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(zcam_F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(zcam_F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  // convert XYZ tristimulus values to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White, int viewingConditions )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType, cat_adaptDegree)), refWhiteIzazbz.x, viewingConditions);\n  \}\n\n\n  // convert the ZCAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White, int viewingConditions )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x, viewingConditions)), d65White, refWhite, catType, cat_adaptDegree);\n  \}\n\n\n  // check if the 3D point 'v' is inside a cube with the dimensions cubeSize x cubeSize x cubeSize \n  // the 'smoothing' parameter rounds off the edges and corners of the cube with the exception of the 0,0,0 and cubeSize x cubeSize x cubeSize corners\n  // a smoothing value of 0.0 applies no smoothing and 1.0 the maximum amount (smoothing values > 1.0 result in undefined behavior )\n  int isInsideCube( float3 v, float cubeSize, float smoothing)\n  \{\n    float3 normv = v / cubeSize;\n\n    float minv = min(normv.x, min(normv.y, normv.z));\n    float maxv = max(normv.x, max(normv.y, normv.z));\n\n    if( smoothing <= 0.0f )\n    \{\n      // when not smoothing we can use a much simpler test\n      if(minv < 0.0f || maxv > 1.0f)\n      \{\n        return 0;\n      \}\n\n      return 1;\n    \}\n\n    float3 clamped = normv;\n\n    float radius = smoothing/2.0f;\n\n    radius = clamp(radius*maxv*(1.0f-minv), 0.0f, radius);\n\n    clamped.x = clamp(normv.x, radius, 1.0f-radius);\n    clamped.y = clamp(normv.y, radius, 1.0f-radius);\n    clamped.z = clamp(normv.z, radius, 1.0f-radius);\n\n\n    if( length(normv - clamped ) > radius)\n    \{\n      return 0;\n    \}\n\n    return 1;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? pow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = pow(v, st2084_m_2_d);\n    return pow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = pow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return pow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return pow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return pow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return pow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n\n  // convert RGB values in the input colorspace to the ZCAM intermediate Izazbz colorspace\n  float3 input_RGB_to_Izazbz(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAX range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAX, HALF_MAX);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    // assuming 'fully adapted', dark' viewing conditions for input image (does that make sense?)\n    return XYZ_to_Izazbz(apply_CAT(luminanceXYZ, inWhite, d65White, catType, 1.0f));\n  \}\n\n\n  // convert values in the ZCAM intermediate Izazbz colorspace to RGB values in the input colorspace\n  float3 Izazbz_to_input_RGB(float3 Izazbz)\n  \{\n    float3 luminanceXYZ = Izazbz_to_XYZ(Izazbz);\n    luminanceXYZ = apply_CAT(luminanceXYZ, d65White, inWhite, catType, 1.0f);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 RGB = luminanceToEncoding3(encodingIn, luminanceRGB);\n    return RGB;\n  \}\n\n  // convert RGB values in the output colorspace to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_ZCAM_JMh(XYZ, refWhite, d65White, viewingConditions);\n    return JMh;\n  \}\n\n\n  // convert ZCAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = ZCAM_JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_ZCAM_JMh(XYZ, refWhite, d65White, viewingConditions);\n    return JMh;\n  \}\n\n\n  // convert ZCAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = ZCAM_JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  // find the JM coordinates of the smoothed boundary of the limiting gamaut in ZCAM at the hue slice 'h' \n  // by searching along the line defined by 'JMSource' and 'JMFocus'\n  // the function will search outwards from where the line intersects the achromatic axis with a staring incement of 'startStepSize'\n  // once the boundary has been crossed it will search in the opposite direction with half the step size\n  // and will repeat this as as many times as is set by the 'precision' paramter\n  float2 findBoundary(float2 JMSource, float2 JMFocus, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB, float smoothing, int precision, float startStepSize )\n  \{\n\n    float2 achromaticIntercept = float2(JMFocus.x - (((JMSource.x-JMFocus.x) / (JMSource.y-JMFocus.y))*JMFocus.y), 0.0f);\n\n    if( achromaticIntercept.x <= 0.0f || achromaticIntercept.x >= limitJmax )\n    \{\n       return achromaticIntercept;\n    \}\n\n\n    float stepSize = startStepSize;\n    float2 unitVector = normalize(achromaticIntercept - JMFocus);\n    float2 JMtest = achromaticIntercept;\n    int searchOutwards = 1;\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMtest = JMtest + unitVector * stepSize;\n        int inside = isInsideCube( vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( float3(JMtest.x, JMtest.y, h), XYZw, XYZd65, viewingConditions ) / referenceLuminance ), boundaryRGB, smoothing);\n\n        if( searchOutwards )\n        \{\n          if( JMtest.x < 0.0f || JMtest.x > limitJmax || JMtest.y > limitMmax || !inside )\n          \{\n            searchOutwards = 0;\n            stepSize = -fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n        else\n        \{\n          if( JMtest.y < 0.0f || inside )\n          \{\n            searchOutwards = 1;\n            stepSize = fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n      \}\n    \}\n\n\n    float2 JMboundary = float2( clamp(JMtest.x, 0.0f, limitJmax), clamp(JMtest.y, 0.0f, limitMmax) );\n\n    return JMboundary;\n  \}\n\n\n  // apply the forward ACES SingleStageToneScale (SSTS) transfom to the linear 'x' input value and return a luminance value\n  float forwardSSTS(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(ssts_coefsLow\[j/3]\[j%3], ssts_coefsLow\[(j+1)/3]\[(j+1)%3], ssts_coefsLow\[(j+2)/3]\[(j+2)%3]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( ssts_m1, cf ));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(ssts_coefsHigh\[j/3]\[j%3], ssts_coefsHigh\[(j+1)/3]\[(j+1)%3], ssts_coefsHigh\[(j+2)/3]\[(j+2)%3]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( ssts_m1, cf ));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return pow(10.0f,logy);\n  \}\n\n  \n  // apply the inverse ACES SingleStageToneScale (SSTS) transfomr to the 'x' luminance value and return an linear value\n  float inverseSSTS(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( ssts_coefsLow\[i/3]\[i%3] + ssts_coefsLow\[(i+1)/3]\[(i+1)%3]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( ssts_coefsHigh\[i/3]\[i%3] + ssts_coefsHigh\[(i+1)/3]\[(i+1)%3]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = ssts_coefsLow\[0]\[0];\n          cf.y = ssts_coefsLow\[0]\[1];\n          cf.z = ssts_coefsLow\[0]\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = ssts_coefsLow\[0]\[1];\n          cf.y = ssts_coefsLow\[0]\[2];\n          cf.z = ssts_coefsLow\[1]\[0];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = ssts_coefsLow\[0]\[2];\n          cf.y = ssts_coefsLow\[1]\[0];\n          cf.z = ssts_coefsLow\[1]\[1];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( ssts_m1, cf );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[0];\n          cf.y = ssts_coefsHigh\[0]\[1];\n          cf.z = ssts_coefsHigh\[0]\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[1];\n          cf.y = ssts_coefsHigh\[0]\[2];\n          cf.z = ssts_coefsHigh\[1]\[0];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[2];\n          cf.y = ssts_coefsHigh\[1]\[0];\n          cf.z = ssts_coefsHigh\[1]\[1];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( ssts_m1, cf );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return pow(10.0f, logx);\n  \}\n\n\n  // convert Iz to luminance\n  // note that the PQ fuction used for Iz differs from the ST2084 function by replacing m_2 with rho\n  // it also includes a luminance shift caused by the 2nd row-sum of the XYZ to LMS matrix not adding up to 1.0\n  float IzToLuminance( float Iz )\n  \{\n    float V_p = pow(Iz, 1.0f / zcam_rho);\n    float luminance = pow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p * zcam_luminance_shift;\n    return luminance;\n  \}\n\n\n  // convert luminance to Iz\n  // note that the PQ fuction used for Iz differs from the ST2084 function by replacing m_2 with rho\n  // it also includes a luminance shift caused by the 2nd row-sum of the XYZ to LMS matrix not adding up to 1.0\n  float luminanceToIz( float luminance )\n  \{\n    float Y_p = pow((luminance/zcam_luminance_shift) / st2084_L_p, st2084_m_1);\n    float Iz = pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), zcam_rho);\n    return Iz;\n  \}\n\n\n  // calculate a scale factor for colorfulness\n  // based on the difference between the original and tone scaled (TS) Iz values\n  // we are only interested in the differences above mid grey\n  // so we first offset the original Iz values to align 18% it with the mid point of the IzTS value\n  float highlightDesatFactor( float Iz, float IzTS )\n  \{\n\n    float linear = IzToLuminance(Iz) / referenceLuminance;\n\n    // no highlight desat below SSTS mid point\n    if( linear < 0.18f )\n    \{\n      return 1.0f;\n    \}\n\n    float IzMid   = luminanceToIz(0.18f * referenceLuminance);\n    float IzMidTS = luminanceToIz(sstsLuminance.y);\n\n    float IzAligned = Iz + IzMidTS - IzMid;\n\n    float desatFactor = 1.0f - clamp( compressPowerP( (log10(max(HALF_MIN, IzAligned)) - log10(max(HALF_MIN, IzTS))) * desatHighlights, compressionFuncParams.x, HALF_MAX, compressionFuncParams.z, 0 ), 0.0f, 1.0f);\n\n    return desatFactor;\n  \}\n\n\n  float3 forwardTonescale( float3 inputIzazbz )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n\n    if( ! applySsts && ! applyHighlightDesat )\n    \{\n      // nothing to do here except converting to JMh\n      return Izazbz_to_JMh(inputIzazbz, refWhiteIzazbz.x, 0);\n    \}\n\n    float linear = IzToLuminance(inputIzazbz.x) / referenceLuminance;\n    float luminanceTS = forwardSSTS(linear, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n    float IzTS = luminanceToIz(luminanceTS);\n\n    float3 outputIzazbz = inputIzazbz;\n\n    if( applySsts )\n    \{\n      outputIzazbz.x = IzTS;\n    \}\n\n    // convert the result to JMh\n    float3 outputJMh = Izazbz_to_JMh(outputIzazbz, refWhiteIzazbz.x, 0);\n\n    if( applyHighlightDesat )\n    \{\n      float factM = highlightDesatFactor(inputIzazbz.x, IzTS);\n      outputJMh.y = outputJMh.y * factM;\n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    float3 Izazbz = JMh_to_Izazbz(JMh, refWhiteIzazbz.x, 0);\n\n    if( ! applySsts && ! applyHighlightDesat )\n    \{\n      // nothing else to do here\n      return Izazbz;\n    \}\n\n    float luminance = IzToLuminance(Izazbz.x);\n    float linear = inverseSSTS(luminance, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n    float Iz = luminanceToIz(linear*referenceLuminance);\n\n    if( applyHighlightDesat )\n    \{\n      float factM = highlightDesatFactor(Iz, Izazbz.x);\n      JMh.y = JMh.y / factM;\n      Izazbz = JMh_to_Izazbz(JMh, refWhiteIzazbz.x, 0);\n      luminance = IzToLuminance(Izazbz.x);\n      linear = inverseSSTS(luminance, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n      Iz = luminanceToIz(linear*referenceLuminance);\n    \}\n\n    if( applySsts )\n    \{\n      Izazbz.x = Iz;\n    \}\n\n    return Izazbz;\n  \}\n\n\n  // compress the ZCAM JM values into the limiting gamut by projecting them towards a focus point beyond the achromatic axis\n  // in order to avoid the gamut compression to also compress black and white tones towards the focus point\n  // (which would result in lifed blacks and crushed highlights)\n  // we offset the focus further away from the achromatic axis the closer the lightness of a sample is to the zero or the limitJmax value\n  // a far away focus point means the compression vector becomes close to orthogonal to the lightness axis preserving black & white lightness\n  // the 'distanceGainCalcJ' paramter should be set to inputJMh.x for the forward direction\n  // and to the best guess of the original, uncompressed values for the inverse direction\n  // this is used for iteratively converging on the original, uncompressed value of J which would have gotten obfuscated by the forward transform\n  float3 compressGamut( float3 inputJMh, int invert, float distanceGainCalcJ )\n  \{\n    if( ! applyGamutCompression )\n    \{\n      return inputJMh;\n    \}\n\n    float sstsMidJ = XYZ_to_ZCAM_JMh( refWhite * sstsLuminance.y, refWhite, d65White, viewingConditions ).x;\n    float2 JMinput = float2(inputJMh.x, inputJMh.y);\n    float2 JMcusp = cuspFromTable( inputJMh.z);\n\n    float focusJ = lerp(JMcusp.x, sstsMidJ, cuspMidBlend);\n\n    float focusDistanceGain = 1.0f;\n\n    if( distanceGainCalcJ > focusJ )\n    \{\n      focusDistanceGain = (limitJmax - focusJ) / max(0.0001f, (limitJmax - min(limitJmax, distanceGainCalcJ)));\n    \}\n    else\n    \{\n      focusDistanceGain = (focusJ) / max(0.0001f, distanceGainCalcJ); \n    \}\n\n    float2 JMfocus = float2( focusJ, -JMcusp.y*focusDistanceClamped*focusDistanceGain );\n    float2 vecToFocus = (JMfocus - JMinput);\n    float2 achromaticIntercept = float2(JMfocus.x - (((JMinput.x-JMfocus.x) / (JMinput.y-JMfocus.y))*JMfocus.y), 0.0f);\n\n    // to reduce the number of expensive boundary finding iterations needed\n    // we taking an educated guess at a good starting step size\n    // based on how far the sample is either above or below the gamut cusp\n    float cuspToTipRatio;\n    if( JMinput.x > JMcusp.x )\n    \{\n      cuspToTipRatio = (JMinput.x - JMcusp.x) / (limitJmax - JMcusp.x);\n    \}\n    else\n    \{\n      cuspToTipRatio = (JMcusp.x - JMinput.x) / (JMcusp.x);\n    \}\n\n    float startStepSize = lerp(JMcusp.y / 3.0f, 0.1f, cuspToTipRatio);\n    float2 JMboundary = findBoundary(JMinput, JMfocus,  inputJMh.z, refWhite, d65White, XYZ_to_RGB_limit, smoothCusps, boundarySolvePrecision, startStepSize);\n    float normFact = 1.0f / max(0.0001f, length(JMboundary - achromaticIntercept));\n    float v = length(JMinput-achromaticIntercept) * normFact;\n    float vCompressed = compressPowerP(v, compressionFuncParams.x, compressionFuncParams.y, compressionFuncParams.z, invert);\n    float2 JMcompressed = achromaticIntercept + normalize(JMinput-achromaticIntercept)*vCompressed/normFact;\n    return float3(JMcompressed.x, JMcompressed.y, inputJMh.z);\n  \}\n\n\n  // apply the forward gamut compression to the limiting primaries\n  float3 compressGamutForward( float3 JMh )\n  \{\n    float3 JMhcompressed = compressGamut( JMh, 0, JMh.x );\n    return JMhcompressed;\n  \}\n\n\n  // apply the inverse gamut compression\n  // and iterate a given number of times to reconstruct the original J value\n  float3 compressGamutInverse( float3 JMh )\n  \{\n    float3 JMhuncompressed;\n    float distanceGainCalcJ = JMh.x;\n\n    for( int i = 0; i < inverseSolverIterations; ++i )\n    \{\n      JMhuncompressed = compressGamut( JMh, 1, distanceGainCalcJ );\n      distanceGainCalcJ = JMhuncompressed.x;\n    \}\n\n    return JMhuncompressed;\n  \}\n\n\n  void init()\n  \{\n    HALF_MIN = 0.0000000596046448f;\n    HALF_MAX = 65504.0f;\n\n    zcam_L_A = referenceLuminance * backgroundLuminance / 100.0f;\n    zcam_F_b = sqrt(backgroundLuminance/referenceLuminance);\n    zcam_F_L = 0.171f*pow(zcam_L_A, 1.0f/3.0f) * (1.0f-exp(-48.0f/9.0f*zcam_L_A));\n\n    if( discountIlluminant )\n    \{\n      cat_adaptDegree = 1.0f;\n    \}\n    else\n    \{\n      float viewingConditionsCoeff = 1.0f;\n\n      if( viewingConditions == 0 )\n      \{\n        viewingConditionsCoeff = 0.8f;\n      \}\n      else if( viewingConditions == 1 )\n      \{\n        viewingConditionsCoeff = 0.9f;\n      \}\n      else if( viewingConditions == 2 )\n      \{\n        viewingConditionsCoeff = 1.0f;\n      \}\n\n      cat_adaptDegree = viewingConditionsCoeff * (1.0f - (1.0f / 3.6f) * exp((-zcam_L_A - 42.0f) / 92.0f));\n    \}\n\n    zcam_cb  = 1.15f;\n    zcam_cg  = 0.66f;\n    zcam_c1  = 3424.0f / pow(2.0f,12.0f);\n    zcam_c2  = 2413.0f / pow(2.0f, 7.0f);\n    zcam_c3  = 2392.0f / pow(2.0f, 7.0f);\n    zcam_eta = 2610.0f / pow(2.0f,14.0f);\n    zcam_rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    zcam_luminance_shift = 1.0f / (-0.20151000f + 1.12064900f + 0.05310080f);\n\n    zcam_viewing_conditions_coeff = 1.0f;\n\n    if( viewingConditions == 0 )\n    \{\n      zcam_viewing_conditions_coeff = 0.525f;\n    \}\n    else if( viewingConditions == 1 )\n    \{\n      zcam_viewing_conditions_coeff = 0.59f;\n    \}\n    else if( viewingConditions == 2 )\n    \{\n      zcam_viewing_conditions_coeff = 0.69f;\n    \}\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    ssts_min_stop_sdr =  -6.5f;\n    ssts_max_stop_sdr =   6.5f;\n    ssts_min_stop_rrt = -15.0f;\n    ssts_max_stop_rrt =  18.0f;\n    ssts_min_lum_sdr = 0.02f;\n    ssts_max_lum_sdr = 48.0f;\n    ssts_min_lum_rrt = 0.0001f;\n    ssts_max_lum_rrt = 10000.0f;\n    ssts_n_knots_low = 4;\n    ssts_n_knots_high = 4;\n\n    ssts_minTable = float4(log10(ssts_min_lum_rrt), ssts_min_stop_rrt, log10(ssts_min_lum_sdr), ssts_min_stop_sdr);\n    ssts_maxTable = float4(log10(ssts_max_lum_sdr), ssts_max_stop_sdr, log10(ssts_max_lum_rrt), ssts_max_stop_rrt);\n    ssts_bendsLow = float4(ssts_min_stop_rrt, 0.18f, ssts_min_stop_sdr, 0.35f);\n    ssts_bendsHigh = float4(ssts_max_stop_sdr, 0.89f, ssts_max_stop_rrt, 0.90f);\n\n    float ssts_m1_data\[]=\{ 0.5f,-1.0f, 0.5f,\n                          -1.0f, 1.0f, 0.0f,\n                           0.5f, 0.5f, 0.0f \};\n    ssts_m1.setArray(ssts_m1_data);\n\n    ssts_min_pt.x = 0.18f * pow(2.0f, lerp1D(ssts_minTable, log10(sstsLuminance.x)));\n    ssts_min_pt.y = sstsLuminance.x;\n    ssts_min_pt.z = 0.0f;\n\n    ssts_mid_pt = float3(0.18f, 4.8f, 1.55f);\n\n    ssts_max_pt.x = 0.18f * pow(2.0f, lerp1D(ssts_maxTable, log10(sstsLuminance.z)));\n    ssts_max_pt.y = sstsLuminance.z;\n    ssts_max_pt.z = 0.0f;\n\n    ssts_knotIncLow  = (log10(ssts_mid_pt.x) - log10(ssts_min_pt.x)) / 3.0f;\n    ssts_knotIncHigh = (log10(ssts_max_pt.x) - log10(ssts_mid_pt.x)) / 3.0f;\n    ssts_pctLow  = lerp1D(ssts_bendsLow,  log2(ssts_min_pt.x / 0.18f));\n    ssts_pctHigh = lerp1D(ssts_bendsHigh, log2(ssts_max_pt.x / 0.18f));\n\n    \n    float ssts_coefsLow_data\[] = \{\n      (ssts_min_pt.z * (log10(ssts_min_pt.x)-0.5f*ssts_knotIncLow)) + ( log10(ssts_min_pt.y) - ssts_min_pt.z * log10(ssts_min_pt.x)),\n      (ssts_min_pt.z * (log10(ssts_min_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_min_pt.y) - ssts_min_pt.z * log10(ssts_min_pt.x)),\n      log10(ssts_min_pt.y) + ssts_pctLow*(log10(ssts_mid_pt.y)-log10(ssts_min_pt.y)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)-0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      0.0f, 0.0f, 0.0f \};\n\n    float sssts_coefsHigh_data\[] = \{\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)-0.5f*ssts_knotIncHigh)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      log10(ssts_mid_pt.y) + ssts_pctHigh*(log10(ssts_max_pt.y)-log10(ssts_mid_pt.y)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)-0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      0.0f, 0.0f, 0.0f \};\n\n    ssts_coefsLow.setArray(ssts_coefsLow_data);\n    ssts_coefsHigh.setArray(sssts_coefsHigh_data);\n\n    ssts_paramMin = ssts_min_pt;\n    ssts_paramMid = ssts_mid_pt;\n    ssts_paramMax = ssts_max_pt;\n    ssts_expShift = log2(inverseSSTS(sstsLuminance.y, ssts_min_pt, ssts_paramMid, ssts_max_pt)) - log2(0.18f);\n    ssts_paramMin.x = pow(2.0f, (log(ssts_paramMin.x) / log(2.0f) - ssts_expShift));\n    ssts_paramMid.x = pow(2.0f, (log(0.18f          ) / log(2.0f) - ssts_expShift));\n    ssts_paramMax.x = pow(2.0f, (log(ssts_paramMax.x) / log(2.0f) - ssts_expShift));\n\n\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11f;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n      \n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n\n    // limitMmax (asumed to coincide with one of the RGBCMY corners of the limitRGB cube)\n    float3 gamutCornersTable\[6];\n    gamutCornersTable\[0] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 0.0f));\n    gamutCornersTable\[1] = limit_RGB_to_JMh(float3(1.0f, 1.0f, 0.0f));\n    gamutCornersTable\[2] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 0.0f));\n    gamutCornersTable\[3] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 1.0f));\n    gamutCornersTable\[4] = limit_RGB_to_JMh(float3(0.0f, 0.0f, 1.0f));\n    gamutCornersTable\[5] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 1.0f));\n\n    limitMmax = 0.0f;\n    for( int i = 0; i < 6; ++i )\n    \{\n      limitMmax = max(limitMmax, gamutCornersTable\[i].y);\n    \}\n\n    // ensure positive, non-zero focus depth\n    // to avoid the gamut boundary search vector becoming zero for achromatic colors\n    // which will cause the boundary search loop to continue forever and the node to hang\n    focusDistanceClamped = max(0.01f, focusDistance);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n\n    if( invert )\n    \{\n      float3 JMh = output_RGB_to_JMh(srcRGB);\n      JMh = compressGamutInverse(JMh);\n      float3 inputIzazbz = inverseTonescale(JMh);\n      dstRGB = Izazbz_to_input_RGB(inputIzazbz);\n    \}\n    else\n    \{\n      float3 inputIzazbz = input_RGB_to_Izazbz(srcRGB);\n      float3 JMh = forwardTonescale(inputIzazbz);\n      JMh = compressGamutForward(JMh);\n      dstRGB = JMh_to_output_RGB(JMh);\n    \}\n\n    dst() = float4(dstRGB.x, dstRGB.y, dstRGB.z, source.w); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_ZCAM_v10_Kernel_encodingIn {{parent.encoding_in}}
  DRT_ZCAM_v10_Kernel_primariesIn {{parent.primaries_in}}
  DRT_ZCAM_v10_Kernel_catType {{parent.cat_type}}
  DRT_ZCAM_v10_Kernel_discountIlluminant {{parent.discount_illuminant}}
  DRT_ZCAM_v10_Kernel_referenceLuminance {{parent.reference_luminance}}
  DRT_ZCAM_v10_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_ZCAM_v10_Kernel_viewingConditions {{parent.viewing_conditions}}
  DRT_ZCAM_v10_Kernel_applySsts {{parent.apply_ssts}}
  DRT_ZCAM_v10_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_ZCAM_v10_Kernel_applyHighlightDesat {{parent.apply_highlight_desat}}
  DRT_ZCAM_v10_Kernel_desatHighlights {{parent.desat_highlights}}
  DRT_ZCAM_v10_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_ZCAM_v10_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_ZCAM_v10_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_ZCAM_v10_Kernel_focusDistance {{parent.focus_distance}}
  DRT_ZCAM_v10_Kernel_compressionFuncParams {{parent.compression_params.x} {parent.compression_params.y} {parent.compression_params.z}}
  DRT_ZCAM_v10_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_ZCAM_v10_Kernel_boundarySolvePrecision {{parent.solve_precision}}
  DRT_ZCAM_v10_Kernel_inverseSolverIterations {{parent.inverse_solver_iterations}}
  DRT_ZCAM_v10_Kernel_encodingOut {{parent.encoding_out}}
  DRT_ZCAM_v10_Kernel_primariesOut {{parent.primaries_out}}
  DRT_ZCAM_v10_Kernel_clampOutput {{parent.clamp_output}}
  DRT_ZCAM_v10_Kernel_invert {{parent.invert}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -231
 }
 Output {
  name Output1
  xpos -908
  ypos -154
 }
end_group
Group {
 inputs 0
 name DRT_ZCAM_IzMh_v10_Blink1
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]"
 note_font "Bitstream Vera Sans"
 xpos -1527
 ypos -546
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 addUserKnob {4 cat_type l "CAT Type" t "the chromatic adaptation transform to use for converting between white points" M {None "XYZ Scaling" Bradford CAT02 Zhai2018 ""}}
 cat_type Zhai2018
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {6 apply_ssts l "apply SSTS" t "toggle the SingleStageToneScale transform" +STARTLINE}
 apply_ssts true
 addUserKnob {13 ssts_luminance l "SSTS luminance" t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {6 apply_highlight_desat l "apply highlight desat" t "toggle de-saturating the highlights above SSTS mid luminance based on how much the SSTS has compressed them" +STARTLINE}
 apply_highlight_desat true
 addUserKnob {7 desat_highlights l "desat highlights" t "the amount of desaturation applied to the highlights" R 0 5}
 desat_highlights 3.5
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 apply_gamut_compression l "apply gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l primaries t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {6 discount_illuminant l "discount illuminant (Zhai2018 only)" t "disable the degree of adaptation model for the Zhai2018 CAT\nthis is only effective if the limiting primaries do not use a D65 white point" -STARTLINE}
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.5
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "gamut cusp (0) to SSTS mid (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "the distance from the achromatic axis of the focal point of the compression where 0.0 is at the achromatic axis and 1.0 the distance of the gamut cusp at the given hue but on the opposite side of the achomatic axis" R 0 2}
 focus_distance 0.5
 addUserKnob {26 focus_depth_label l " " -STARTLINE T "achromatic (0) to cusp opposite (1)"}
 addUserKnob {13 compression_params l compression t "the threshold, limit and power parameters for the PowerP compression function\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.2 1.2}
 addUserKnob {26 compression_params_label l " " -STARTLINE T "threshold / limit / power"}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.25
 addUserKnob {3 solve_precision l "solve precision" t "the number of iterations used for finding the gamut boundary using the interval bisection method"}
 solve_precision 10
 addUserKnob {3 inverse_solver_iterations l "inverse solver iterations" t "the number of iterations used for finding the original J & M values when applying the inverse gamut compression"}
 inverse_solver_iterations 10
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -294
 }
 BlinkScript {
  recompileCount 129
  ProgramGroup 1
  KernelDescription "2 \"DRT_ZCAM_v10_Kernel\" iterate pixelWise 1fceba9d8fc7d80461dce7173d563f0516f7ee3a72e55c23f8125f688a68235d 2 \"src\" Read Point \"dst\" Write Point 23 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"discountIlluminant\" Bool 1 AA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"applySsts\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyHighlightDesat\" Bool 1 AA== \"desatHighlights\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"boundarySolvePrecision\" Int 1 AAAAAA== \"inverseSolverIterations\" Int 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"invert\" Bool 1 AA== 23 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"catType\" 1 1 \"discountIlluminant\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"applySsts\" 1 1 \"sstsLuminance\" 3 1 \"applyHighlightDesat\" 1 1 \"desatHighlights\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 3 1 \"smoothCusps\" 1 1 \"boundarySolvePrecision\" 1 1 \"inverseSolverIterations\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"invert\" 1 1 72 \"HALF_MIN\" Float 1 1 AAAAAA== \"HALF_MAX\" Float 1 1 AAAAAA== \"zcam_L_A\" Float 1 1 AAAAAA== \"zcam_F_b\" Float 1 1 AAAAAA== \"zcam_F_L\" Float 1 1 AAAAAA== \"zcam_cb\" Float 1 1 AAAAAA== \"zcam_cg\" Float 1 1 AAAAAA== \"zcam_c1\" Float 1 1 AAAAAA== \"zcam_c2\" Float 1 1 AAAAAA== \"zcam_c3\" Float 1 1 AAAAAA== \"zcam_eta\" Float 1 1 AAAAAA== \"zcam_rho\" Float 1 1 AAAAAA== \"zcam_luminance_shift\" Float 1 1 AAAAAA== \"zcam_viewing_conditions_coeff\" Float 1 1 AAAAAA== \"cat_adaptDegree\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"ssts_min_stop_sdr\" Float 1 1 AAAAAA== \"ssts_max_stop_sdr\" Float 1 1 AAAAAA== \"ssts_min_stop_rrt\" Float 1 1 AAAAAA== \"ssts_max_stop_rrt\" Float 1 1 AAAAAA== \"ssts_min_lum_sdr\" Float 1 1 AAAAAA== \"ssts_max_lum_sdr\" Float 1 1 AAAAAA== \"ssts_min_lum_rrt\" Float 1 1 AAAAAA== \"ssts_max_lum_rrt\" Float 1 1 AAAAAA== \"ssts_n_knots_low\" Int 1 1 AAAAAA== \"ssts_n_knots_high\" Int 1 1 AAAAAA== \"ssts_m1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_minTable\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_maxTable\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_bendsLow\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_bendsHigh\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_min_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_mid_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_max_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_knotIncLow\" Float 1 1 AAAAAA== \"ssts_knotIncHigh\" Float 1 1 AAAAAA== \"ssts_pctLow\" Float 1 1 AAAAAA== \"ssts_pctHigh\" Float 1 1 AAAAAA== \"ssts_coefsLow\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_coefsHigh\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_expShift\" Float 1 1 AAAAAA== \"ssts_paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_ZCAM\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"limitMmax\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"focusDistanceClamped\" Float 1 1 AAAAAA=="
  kernelSource "\nkernel DRT_ZCAM_v10_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    //\n    // ZCAM Paramters\n    //\n\n    // Chomatic Adaptation Transform to Use\n    // 0: None\n    // 1: XYZ Scaling\n    // 2: Bradford\n    // 3: CAT02\n    // 4: Zhai2018 (two-step)\n    int catType;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n\n    //\n    // SSTS Parameters\n    //\n\n    // Toggle SSTS Tone Mapping\n    bool applySsts;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle Highlight De-Saturation\n    bool applyHighlightDesat;\n\n    // Scale the De-Saturation Applied to the Highlights\n    float desatHighlights;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // the distance of the compression focal point\n    // from the achromatic axis\n    // normalised to the distance of the gamut cusp\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / Limit / Power\n    float3 compressionFuncParams;\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    // When solving for the target gamut boundary\n    // how many search interval halving steps to perform\n    int boundarySolvePrecision;\n\n    // Number of iterations to converge on the uncompressed J value \n    // Because of the compression focus point changes depending on the J value of the uncompressed sample\n    // we cannot perfectly invert it since the original J value has now been changed by the forward compression\n    // we can converge on a reasonable approximation of the original J value by iterating the inverse compression\n    // although this is quite an expensive operation\n    int inverseSolverIterations;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n\n  local:\n\n    // constants\n    float HALF_MIN;\n    float HALF_MAX;\n\n    // ZCAM vars\n    float zcam_L_A;\n    float zcam_F_b;\n    float zcam_F_L;\n    float zcam_cb;\n    float zcam_cg;\n    float zcam_c1;\n    float zcam_c2;\n    float zcam_c3;\n    float zcam_eta;\n    float zcam_rho;\n    float zcam_luminance_shift;\n    float zcam_viewing_conditions_coeff;\n\n    // CAT vars\n    float cat_adaptDegree;\n\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // SSTS constants\n    float ssts_min_stop_sdr;\n    float ssts_max_stop_sdr;\n    float ssts_min_stop_rrt;\n    float ssts_max_stop_rrt;\n    float ssts_min_lum_sdr;\n    float ssts_max_lum_sdr;\n    float ssts_min_lum_rrt;\n    float ssts_max_lum_rrt;\n    int ssts_n_knots_low;\n    int ssts_n_knots_high;\n    float3x3 ssts_m1;\n\n    // SSTS tables\n    // using the float4 type to store the two 2D vectors\n    // because Blink does not support generic array assignments\n    float4 ssts_minTable;\n    float4 ssts_maxTable;\n    float4 ssts_bendsLow;\n    float4 ssts_bendsHigh;\n\n    // SSTS parameters\n    float3 ssts_min_pt;\n    float3 ssts_mid_pt;\n    float3 ssts_max_pt;\n    float ssts_knotIncLow;\n    float ssts_knotIncHigh;\n    float ssts_pctLow;\n    float ssts_pctHigh;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n    float3x3 ssts_coefsLow;\n    float3x3 ssts_coefsHigh;\n\n    float ssts_expShift;\n    float3 ssts_paramMin;\n    float3 ssts_paramMid;\n    float3 ssts_paramMax;\n\n\n    // matrix vars\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 refWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // the maximum colorfulness value of the limiting gamut\n    float limitMmax;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given ZCAM hue (h) value \n    // one must search the table entries for the mathcing entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since tempoary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n\n    // local version of the public focusDistance parameter\n    // this one will be clamped to a value > 0.0\n    float focusDistanceClamped;\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // get the y value of f(x) where the fuction is defined as a line between two points\n  // the two points as passed as an array \[a.x, a.y, b.x, b.y]\n  float lerp1D( float4 table, float x)\n  \{\n    float m = (table.w-table.y) / (table.z-table.x);\n    float c = table.y - (m*table.x);\n    float y = x*m+c;\n    return y;\n  \}\n\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially retured -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // Two-Stage chromatic adaptation transforms as proposed by  Zhai, Q., & Luo, M. R. (2018)\n  // https://opg.optica.org/oe/fulltext.cfm?uri=oe-26-6-7724\n  // https://github.com/colour-science/colour/blob/e5fa0790adcc3e5df5fa42ddf2bb75214c8cf59c/colour/adaptation/zhai2018.py\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n  // apply chromatic adaptation transform to 'XYZ' from 'XYZ_ws' to 'XYZ_wd' white points\n  // 'type' selects the cone fundamentals matrix (exept for Zhai2018 which uses a 2-stage tranforms based on CATO2 fundamentals)\n  // 'adaptDegree' sets the degree of adaptation for the Zhai2018 model\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type, float adaptDegree )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  // convert XYZ tristimulus values to the ZCAM intermediate Izazbz colorspace\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = zcam_cb * XYZD65.x - (zcam_cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = zcam_cg * XYZD65.y - (zcam_cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( zcam_c1 + zcam_c2 * spow((LMS.x/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.x/10000.0f),zcam_eta) ), zcam_rho);\n    LMSp.y = spow( ( zcam_c1 + zcam_c2 * spow((LMS.y/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.y/10000.0f),zcam_eta) ), zcam_rho);\n    LMSp.z = spow( ( zcam_c1 + zcam_c2 * spow((LMS.z/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.z/10000.0f),zcam_eta) ), zcam_rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    return Izazbz;\n  \}\n\n\n  // convert the ZCAM intermediate Izazbz colorspace to XYZ tristimulus values\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((zcam_c1-spow(LMSp.x,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.x,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    LMS.y = 10000.0f*spow((zcam_c1-spow(LMSp.y,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.y,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    LMS.z = 10000.0f*spow((zcam_c1-spow(LMSp.z,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.z,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(zcam_cb-1.0f)*XYZpD65.z)/zcam_cb;\n    XYZD65.y = (XYZpD65.y+(zcam_cg-1.0f)*XYZD65.x)/zcam_cg;\n    return XYZD65;\n  \}\n\n\n  // convert the ZCAM intermediate Izazbz colorspace to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs the Iz values of the reference white and the viewing conditions parameters\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz, int viewingConditions )\n  \{\n    float3 JMh = 0.0f;\n    float zcam_F_s = zcam_viewing_conditions_coeff;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(zcam_F_L, 0.2f)) / (pow(zcam_F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n  \}\n\n\n  // convert the ZCAM J (lightness), M (colorfulness) and h (hue) correlates to the ZCAM intermediate Izazbz colorspace\n  // needs the Iz values of the reference white and the viewing conditions parameters\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz, int viewingConditions )\n  \{\n    float zcam_F_s = zcam_viewing_conditions_coeff;\n    float Qzm = pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    float Qzw = 2700.0f * pow(refWhiteIz, (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * Qzm;\n    float Izp = pow(zcam_F_b, 0.12f) / (1.6f * zcam_F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * pow(refWhiteIz, 0.78f) * pow(zcam_F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * pow(zcam_F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  // convert XYZ tristimulus values to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White, int viewingConditions )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType, cat_adaptDegree)), refWhiteIzazbz.x, viewingConditions);\n  \}\n\n\n  // convert the ZCAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White, int viewingConditions )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x, viewingConditions)), d65White, refWhite, catType, cat_adaptDegree);\n  \}\n\n\n  // check if the 3D point 'v' is inside a cube with the dimensions cubeSize x cubeSize x cubeSize \n  // the 'smoothing' parameter rounds off the edges and corners of the cube with the exception of the 0,0,0 and cubeSize x cubeSize x cubeSize corners\n  // a smoothing value of 0.0 applies no smoothing and 1.0 the maximum amount (smoothing values > 1.0 result in undefined behavior )\n  int isInsideCube( float3 v, float cubeSize, float smoothing)\n  \{\n    float3 normv = v / cubeSize;\n\n    float minv = min(normv.x, min(normv.y, normv.z));\n    float maxv = max(normv.x, max(normv.y, normv.z));\n\n    if( smoothing <= 0.0f )\n    \{\n      // when not smoothing we can use a much simpler test\n      if(minv < 0.0f || maxv > 1.0f)\n      \{\n        return 0;\n      \}\n\n      return 1;\n    \}\n\n    float3 clamped = normv;\n\n    float radius = smoothing/2.0f;\n\n    radius = clamp(radius*maxv*(1.0f-minv), 0.0f, radius);\n\n    clamped.x = clamp(normv.x, radius, 1.0f-radius);\n    clamped.y = clamp(normv.y, radius, 1.0f-radius);\n    clamped.z = clamp(normv.z, radius, 1.0f-radius);\n\n\n    if( length(normv - clamped ) > radius)\n    \{\n      return 0;\n    \}\n\n    return 1;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? pow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = pow(v, st2084_m_2_d);\n    return pow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = pow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return pow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return pow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return pow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return pow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n\n  // convert RGB values in the input colorspace to the ZCAM intermediate Izazbz colorspace\n  float3 input_RGB_to_Izazbz(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAX range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAX, HALF_MAX);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    // assuming 'fully adapted', dark' viewing conditions for input image (does that make sense?)\n    return XYZ_to_Izazbz(apply_CAT(luminanceXYZ, inWhite, d65White, catType, 1.0f));\n  \}\n\n\n  // convert values in the ZCAM intermediate Izazbz colorspace to RGB values in the input colorspace\n  float3 Izazbz_to_input_RGB(float3 Izazbz)\n  \{\n    float3 luminanceXYZ = Izazbz_to_XYZ(Izazbz);\n    luminanceXYZ = apply_CAT(luminanceXYZ, d65White, inWhite, catType, 1.0f);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 RGB = luminanceToEncoding3(encodingIn, luminanceRGB);\n    return RGB;\n  \}\n\n  // convert RGB values in the output colorspace to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_ZCAM_JMh(XYZ, refWhite, d65White, viewingConditions);\n    return JMh;\n  \}\n\n\n  // convert ZCAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = ZCAM_JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_ZCAM_JMh(XYZ, refWhite, d65White, viewingConditions);\n    return JMh;\n  \}\n\n\n  // convert ZCAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = ZCAM_JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  // find the JM coordinates of the smoothed boundary of the limiting gamaut in ZCAM at the hue slice 'h' \n  // by searching along the line defined by 'JMSource' and 'JMFocus'\n  // the function will search outwards from where the line intersects the achromatic axis with a staring incement of 'startStepSize'\n  // once the boundary has been crossed it will search in the opposite direction with half the step size\n  // and will repeat this as as many times as is set by the 'precision' paramter\n  float2 findBoundary(float2 JMSource, float2 JMFocus, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB, float smoothing, int precision, float startStepSize )\n  \{\n\n    float2 achromaticIntercept = float2(JMFocus.x - (((JMSource.x-JMFocus.x) / (JMSource.y-JMFocus.y))*JMFocus.y), 0.0f);\n\n    if( achromaticIntercept.x <= 0.0f || achromaticIntercept.x >= limitJmax )\n    \{\n       return achromaticIntercept;\n    \}\n\n\n    float stepSize = startStepSize;\n    float2 unitVector = normalize(achromaticIntercept - JMFocus);\n    float2 JMtest = achromaticIntercept;\n    int searchOutwards = 1;\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMtest = JMtest + unitVector * stepSize;\n        int inside = isInsideCube( vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( float3(JMtest.x, JMtest.y, h), XYZw, XYZd65, viewingConditions ) / referenceLuminance ), boundaryRGB, smoothing);\n\n        if( searchOutwards )\n        \{\n          if( JMtest.x < 0.0f || JMtest.x > limitJmax || JMtest.y > limitMmax || !inside )\n          \{\n            searchOutwards = 0;\n            stepSize = -fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n        else\n        \{\n          if( JMtest.y < 0.0f || inside )\n          \{\n            searchOutwards = 1;\n            stepSize = fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n      \}\n    \}\n\n\n    float2 JMboundary = float2( clamp(JMtest.x, 0.0f, limitJmax), clamp(JMtest.y, 0.0f, limitMmax) );\n\n    return JMboundary;\n  \}\n\n\n  // apply the forward ACES SingleStageToneScale (SSTS) transfom to the linear 'x' input value and return a luminance value\n  float forwardSSTS(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(ssts_coefsLow\[j/3]\[j%3], ssts_coefsLow\[(j+1)/3]\[(j+1)%3], ssts_coefsLow\[(j+2)/3]\[(j+2)%3]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( ssts_m1, cf ));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(ssts_coefsHigh\[j/3]\[j%3], ssts_coefsHigh\[(j+1)/3]\[(j+1)%3], ssts_coefsHigh\[(j+2)/3]\[(j+2)%3]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( ssts_m1, cf ));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return pow(10.0f,logy);\n  \}\n\n  \n  // apply the inverse ACES SingleStageToneScale (SSTS) transfomr to the 'x' luminance value and return an linear value\n  float inverseSSTS(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( ssts_coefsLow\[i/3]\[i%3] + ssts_coefsLow\[(i+1)/3]\[(i+1)%3]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( ssts_coefsHigh\[i/3]\[i%3] + ssts_coefsHigh\[(i+1)/3]\[(i+1)%3]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = ssts_coefsLow\[0]\[0];\n          cf.y = ssts_coefsLow\[0]\[1];\n          cf.z = ssts_coefsLow\[0]\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = ssts_coefsLow\[0]\[1];\n          cf.y = ssts_coefsLow\[0]\[2];\n          cf.z = ssts_coefsLow\[1]\[0];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = ssts_coefsLow\[0]\[2];\n          cf.y = ssts_coefsLow\[1]\[0];\n          cf.z = ssts_coefsLow\[1]\[1];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( ssts_m1, cf );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[0];\n          cf.y = ssts_coefsHigh\[0]\[1];\n          cf.z = ssts_coefsHigh\[0]\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[1];\n          cf.y = ssts_coefsHigh\[0]\[2];\n          cf.z = ssts_coefsHigh\[1]\[0];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[2];\n          cf.y = ssts_coefsHigh\[1]\[0];\n          cf.z = ssts_coefsHigh\[1]\[1];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( ssts_m1, cf );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return pow(10.0f, logx);\n  \}\n\n\n  // convert Iz to luminance\n  // note that the PQ fuction used for Iz differs from the ST2084 function by replacing m_2 with rho\n  // it also includes a luminance shift caused by the 2nd row-sum of the XYZ to LMS matrix not adding up to 1.0\n  float IzToLuminance( float Iz )\n  \{\n    float V_p = pow(Iz, 1.0f / zcam_rho);\n    float luminance = pow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p * zcam_luminance_shift;\n    return luminance;\n  \}\n\n\n  // convert luminance to Iz\n  // note that the PQ fuction used for Iz differs from the ST2084 function by replacing m_2 with rho\n  // it also includes a luminance shift caused by the 2nd row-sum of the XYZ to LMS matrix not adding up to 1.0\n  float luminanceToIz( float luminance )\n  \{\n    float Y_p = pow((luminance/zcam_luminance_shift) / st2084_L_p, st2084_m_1);\n    float Iz = pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), zcam_rho);\n    return Iz;\n  \}\n\n\n  // calculate a scale factor for colorfulness\n  // based on the difference between the original and tone scaled (TS) Iz values\n  // we are only interested in the differences above mid grey\n  // so we first offset the original Iz values to align 18% it with the mid point of the IzTS value\n  float highlightDesatFactor( float Iz, float IzTS )\n  \{\n\n    float linear = IzToLuminance(Iz) / referenceLuminance;\n\n    // no highlight desat below SSTS mid point\n    if( linear < 0.18f )\n    \{\n      return 1.0f;\n    \}\n\n    float IzMid   = luminanceToIz(0.18f * referenceLuminance);\n    float IzMidTS = luminanceToIz(sstsLuminance.y);\n\n    float IzAligned = Iz + IzMidTS - IzMid;\n\n    float desatFactor = 1.0f - clamp( compressPowerP( (log10(max(HALF_MIN, IzAligned)) - log10(max(HALF_MIN, IzTS))) * desatHighlights, compressionFuncParams.x, HALF_MAX, compressionFuncParams.z, 0 ), 0.0f, 1.0f);\n\n    return desatFactor;\n  \}\n\n\n  float3 forwardTonescale( float3 inputIzazbz )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n\n    if( ! applySsts && ! applyHighlightDesat )\n    \{\n      // nothing to do here except converting to JMh\n      return Izazbz_to_JMh(inputIzazbz, refWhiteIzazbz.x, 0);\n    \}\n\n    float linear = IzToLuminance(inputIzazbz.x) / referenceLuminance;\n    float luminanceTS = forwardSSTS(linear, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n    float IzTS = luminanceToIz(luminanceTS);\n\n    float3 outputIzazbz = inputIzazbz;\n\n    if( applySsts )\n    \{\n      outputIzazbz.x = IzTS;\n    \}\n\n    // convert the result to JMh\n    float3 outputJMh = Izazbz_to_JMh(outputIzazbz, refWhiteIzazbz.x, 0);\n\n    if( applyHighlightDesat )\n    \{\n      float factM = highlightDesatFactor(inputIzazbz.x, IzTS);\n      outputJMh.y = outputJMh.y * factM;\n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    float3 Izazbz = JMh_to_Izazbz(JMh, refWhiteIzazbz.x, 0);\n\n    if( ! applySsts && ! applyHighlightDesat )\n    \{\n      // nothing else to do here\n      return Izazbz;\n    \}\n\n    float luminance = IzToLuminance(Izazbz.x);\n    float linear = inverseSSTS(luminance, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n    float Iz = luminanceToIz(linear*referenceLuminance);\n\n    if( applyHighlightDesat )\n    \{\n      float factM = highlightDesatFactor(Iz, Izazbz.x);\n      JMh.y = JMh.y / factM;\n      Izazbz = JMh_to_Izazbz(JMh, refWhiteIzazbz.x, 0);\n      luminance = IzToLuminance(Izazbz.x);\n      linear = inverseSSTS(luminance, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n      Iz = luminanceToIz(linear*referenceLuminance);\n    \}\n\n    if( applySsts )\n    \{\n      Izazbz.x = Iz;\n    \}\n\n    return Izazbz;\n  \}\n\n\n  // compress the ZCAM JM values into the limiting gamut by projecting them towards a focus point beyond the achromatic axis\n  // in order to avoid the gamut compression to also compress black and white tones towards the focus point\n  // (which would result in lifed blacks and crushed highlights)\n  // we offset the focus further away from the achromatic axis the closer the lightness of a sample is to the zero or the limitJmax value\n  // a far away focus point means the compression vector becomes close to orthogonal to the lightness axis preserving black & white lightness\n  // the 'distanceGainCalcJ' paramter should be set to inputJMh.x for the forward direction\n  // and to the best guess of the original, uncompressed values for the inverse direction\n  // this is used for iteratively converging on the original, uncompressed value of J which would have gotten obfuscated by the forward transform\n  float3 compressGamut( float3 inputJMh, int invert, float distanceGainCalcJ )\n  \{\n    if( ! applyGamutCompression )\n    \{\n      return inputJMh;\n    \}\n\n    float sstsMidJ = XYZ_to_ZCAM_JMh( refWhite * sstsLuminance.y, refWhite, d65White, viewingConditions ).x;\n    float2 JMinput = float2(inputJMh.x, inputJMh.y);\n    float2 JMcusp = cuspFromTable( inputJMh.z);\n\n    float focusJ = lerp(JMcusp.x, sstsMidJ, cuspMidBlend);\n\n    float focusDistanceGain = 1.0f;\n\n    if( distanceGainCalcJ > focusJ )\n    \{\n      focusDistanceGain = (limitJmax - focusJ) / max(0.0001f, (limitJmax - min(limitJmax, distanceGainCalcJ)));\n    \}\n    else\n    \{\n      focusDistanceGain = (focusJ) / max(0.0001f, distanceGainCalcJ); \n    \}\n\n    float2 JMfocus = float2( focusJ, -JMcusp.y*focusDistanceClamped*focusDistanceGain );\n    float2 vecToFocus = (JMfocus - JMinput);\n    float2 achromaticIntercept = float2(JMfocus.x - (((JMinput.x-JMfocus.x) / (JMinput.y-JMfocus.y))*JMfocus.y), 0.0f);\n\n    // to reduce the number of expensive boundary finding iterations needed\n    // we taking an educated guess at a good starting step size\n    // based on how far the sample is either above or below the gamut cusp\n    float cuspToTipRatio;\n    if( JMinput.x > JMcusp.x )\n    \{\n      cuspToTipRatio = (JMinput.x - JMcusp.x) / (limitJmax - JMcusp.x);\n    \}\n    else\n    \{\n      cuspToTipRatio = (JMcusp.x - JMinput.x) / (JMcusp.x);\n    \}\n\n    float startStepSize = lerp(JMcusp.y / 3.0f, 0.1f, cuspToTipRatio);\n    float2 JMboundary = findBoundary(JMinput, JMfocus,  inputJMh.z, refWhite, d65White, XYZ_to_RGB_limit, smoothCusps, boundarySolvePrecision, startStepSize);\n    float normFact = 1.0f / max(0.0001f, length(JMboundary - achromaticIntercept));\n    float v = length(JMinput-achromaticIntercept) * normFact;\n    float vCompressed = compressPowerP(v, compressionFuncParams.x, compressionFuncParams.y, compressionFuncParams.z, invert);\n    float2 JMcompressed = achromaticIntercept + normalize(JMinput-achromaticIntercept)*vCompressed/normFact;\n    return float3(JMcompressed.x, JMcompressed.y, inputJMh.z);\n  \}\n\n\n  // apply the forward gamut compression to the limiting primaries\n  float3 compressGamutForward( float3 JMh )\n  \{\n    float3 JMhcompressed = compressGamut( JMh, 0, JMh.x );\n    return JMhcompressed;\n  \}\n\n\n  // apply the inverse gamut compression\n  // and iterate a given number of times to reconstruct the original J value\n  float3 compressGamutInverse( float3 JMh )\n  \{\n    float3 JMhuncompressed;\n    float distanceGainCalcJ = JMh.x;\n\n    for( int i = 0; i < inverseSolverIterations; ++i )\n    \{\n      JMhuncompressed = compressGamut( JMh, 1, distanceGainCalcJ );\n      distanceGainCalcJ = JMhuncompressed.x;\n    \}\n\n    return JMhuncompressed;\n  \}\n\n\n  void init()\n  \{\n    HALF_MIN = 0.0000000596046448f;\n    HALF_MAX = 65504.0f;\n\n    zcam_L_A = referenceLuminance * backgroundLuminance / 100.0f;\n    zcam_F_b = sqrt(backgroundLuminance/referenceLuminance);\n    zcam_F_L = 0.171f*pow(zcam_L_A, 1.0f/3.0f) * (1.0f-exp(-48.0f/9.0f*zcam_L_A));\n\n    if( discountIlluminant )\n    \{\n      cat_adaptDegree = 1.0f;\n    \}\n    else\n    \{\n      float viewingConditionsCoeff = 1.0f;\n\n      if( viewingConditions == 0 )\n      \{\n        viewingConditionsCoeff = 0.8f;\n      \}\n      else if( viewingConditions == 1 )\n      \{\n        viewingConditionsCoeff = 0.9f;\n      \}\n      else if( viewingConditions == 2 )\n      \{\n        viewingConditionsCoeff = 1.0f;\n      \}\n\n      cat_adaptDegree = viewingConditionsCoeff * (1.0f - (1.0f / 3.6f) * exp((-zcam_L_A - 42.0f) / 92.0f));\n    \}\n\n    zcam_cb  = 1.15f;\n    zcam_cg  = 0.66f;\n    zcam_c1  = 3424.0f / pow(2.0f,12.0f);\n    zcam_c2  = 2413.0f / pow(2.0f, 7.0f);\n    zcam_c3  = 2392.0f / pow(2.0f, 7.0f);\n    zcam_eta = 2610.0f / pow(2.0f,14.0f);\n    zcam_rho = 1.7f * 2523.0f / pow(2.0f,5.0f);\n    zcam_luminance_shift = 1.0f / (-0.20151000f + 1.12064900f + 0.05310080f);\n\n    zcam_viewing_conditions_coeff = 1.0f;\n\n    if( viewingConditions == 0 )\n    \{\n      zcam_viewing_conditions_coeff = 0.525f;\n    \}\n    else if( viewingConditions == 1 )\n    \{\n      zcam_viewing_conditions_coeff = 0.59f;\n    \}\n    else if( viewingConditions == 2 )\n    \{\n      zcam_viewing_conditions_coeff = 0.69f;\n    \}\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    ssts_min_stop_sdr =  -6.5f;\n    ssts_max_stop_sdr =   6.5f;\n    ssts_min_stop_rrt = -15.0f;\n    ssts_max_stop_rrt =  18.0f;\n    ssts_min_lum_sdr = 0.02f;\n    ssts_max_lum_sdr = 48.0f;\n    ssts_min_lum_rrt = 0.0001f;\n    ssts_max_lum_rrt = 10000.0f;\n    ssts_n_knots_low = 4;\n    ssts_n_knots_high = 4;\n\n    ssts_minTable = float4(log10(ssts_min_lum_rrt), ssts_min_stop_rrt, log10(ssts_min_lum_sdr), ssts_min_stop_sdr);\n    ssts_maxTable = float4(log10(ssts_max_lum_sdr), ssts_max_stop_sdr, log10(ssts_max_lum_rrt), ssts_max_stop_rrt);\n    ssts_bendsLow = float4(ssts_min_stop_rrt, 0.18f, ssts_min_stop_sdr, 0.35f);\n    ssts_bendsHigh = float4(ssts_max_stop_sdr, 0.89f, ssts_max_stop_rrt, 0.90f);\n\n    float ssts_m1_data\[]=\{ 0.5f,-1.0f, 0.5f,\n                          -1.0f, 1.0f, 0.0f,\n                           0.5f, 0.5f, 0.0f \};\n    ssts_m1.setArray(ssts_m1_data);\n\n    ssts_min_pt.x = 0.18f * pow(2.0f, lerp1D(ssts_minTable, log10(sstsLuminance.x)));\n    ssts_min_pt.y = sstsLuminance.x;\n    ssts_min_pt.z = 0.0f;\n\n    ssts_mid_pt = float3(0.18f, 4.8f, 1.55f);\n\n    ssts_max_pt.x = 0.18f * pow(2.0f, lerp1D(ssts_maxTable, log10(sstsLuminance.z)));\n    ssts_max_pt.y = sstsLuminance.z;\n    ssts_max_pt.z = 0.0f;\n\n    ssts_knotIncLow  = (log10(ssts_mid_pt.x) - log10(ssts_min_pt.x)) / 3.0f;\n    ssts_knotIncHigh = (log10(ssts_max_pt.x) - log10(ssts_mid_pt.x)) / 3.0f;\n    ssts_pctLow  = lerp1D(ssts_bendsLow,  log2(ssts_min_pt.x / 0.18f));\n    ssts_pctHigh = lerp1D(ssts_bendsHigh, log2(ssts_max_pt.x / 0.18f));\n\n    \n    float ssts_coefsLow_data\[] = \{\n      (ssts_min_pt.z * (log10(ssts_min_pt.x)-0.5f*ssts_knotIncLow)) + ( log10(ssts_min_pt.y) - ssts_min_pt.z * log10(ssts_min_pt.x)),\n      (ssts_min_pt.z * (log10(ssts_min_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_min_pt.y) - ssts_min_pt.z * log10(ssts_min_pt.x)),\n      log10(ssts_min_pt.y) + ssts_pctLow*(log10(ssts_mid_pt.y)-log10(ssts_min_pt.y)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)-0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      0.0f, 0.0f, 0.0f \};\n\n    float sssts_coefsHigh_data\[] = \{\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)-0.5f*ssts_knotIncHigh)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      log10(ssts_mid_pt.y) + ssts_pctHigh*(log10(ssts_max_pt.y)-log10(ssts_mid_pt.y)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)-0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      0.0f, 0.0f, 0.0f \};\n\n    ssts_coefsLow.setArray(ssts_coefsLow_data);\n    ssts_coefsHigh.setArray(sssts_coefsHigh_data);\n\n    ssts_paramMin = ssts_min_pt;\n    ssts_paramMid = ssts_mid_pt;\n    ssts_paramMax = ssts_max_pt;\n    ssts_expShift = log2(inverseSSTS(sstsLuminance.y, ssts_min_pt, ssts_paramMid, ssts_max_pt)) - log2(0.18f);\n    ssts_paramMin.x = pow(2.0f, (log(ssts_paramMin.x) / log(2.0f) - ssts_expShift));\n    ssts_paramMid.x = pow(2.0f, (log(0.18f          ) / log(2.0f) - ssts_expShift));\n    ssts_paramMax.x = pow(2.0f, (log(ssts_paramMax.x) / log(2.0f) - ssts_expShift));\n\n\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11f;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n      \n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n\n    // limitMmax (asumed to coincide with one of the RGBCMY corners of the limitRGB cube)\n    float3 gamutCornersTable\[6];\n    gamutCornersTable\[0] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 0.0f));\n    gamutCornersTable\[1] = limit_RGB_to_JMh(float3(1.0f, 1.0f, 0.0f));\n    gamutCornersTable\[2] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 0.0f));\n    gamutCornersTable\[3] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 1.0f));\n    gamutCornersTable\[4] = limit_RGB_to_JMh(float3(0.0f, 0.0f, 1.0f));\n    gamutCornersTable\[5] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 1.0f));\n\n    limitMmax = 0.0f;\n    for( int i = 0; i < 6; ++i )\n    \{\n      limitMmax = max(limitMmax, gamutCornersTable\[i].y);\n    \}\n\n    // ensure positive, non-zero focus depth\n    // to avoid the gamut boundary search vector becoming zero for achromatic colors\n    // which will cause the boundary search loop to continue forever and the node to hang\n    focusDistanceClamped = max(0.01f, focusDistance);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n\n    if( invert )\n    \{\n      float3 JMh = output_RGB_to_JMh(srcRGB);\n      JMh = compressGamutInverse(JMh);\n      float3 inputIzazbz = inverseTonescale(JMh);\n      dstRGB = Izazbz_to_input_RGB(inputIzazbz);\n    \}\n    else\n    \{\n      float3 inputIzazbz = input_RGB_to_Izazbz(srcRGB);\n      float3 JMh = forwardTonescale(inputIzazbz);\n      JMh = compressGamutForward(JMh);\n      dstRGB = JMh_to_output_RGB(JMh);\n    \}\n\n    dst() = float4(dstRGB.x, dstRGB.y, dstRGB.z, source.w); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_ZCAM_v10_Kernel_encodingIn {{parent.encoding_in}}
  DRT_ZCAM_v10_Kernel_primariesIn {{parent.primaries_in}}
  DRT_ZCAM_v10_Kernel_catType {{parent.cat_type}}
  DRT_ZCAM_v10_Kernel_discountIlluminant {{parent.discount_illuminant}}
  DRT_ZCAM_v10_Kernel_referenceLuminance {{parent.reference_luminance}}
  DRT_ZCAM_v10_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_ZCAM_v10_Kernel_viewingConditions {{parent.viewing_conditions}}
  DRT_ZCAM_v10_Kernel_applySsts {{parent.apply_ssts}}
  DRT_ZCAM_v10_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_ZCAM_v10_Kernel_applyHighlightDesat {{parent.apply_highlight_desat}}
  DRT_ZCAM_v10_Kernel_desatHighlights {{parent.desat_highlights}}
  DRT_ZCAM_v10_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_ZCAM_v10_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_ZCAM_v10_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_ZCAM_v10_Kernel_focusDistance {{parent.focus_distance}}
  DRT_ZCAM_v10_Kernel_compressionFuncParams {{parent.compression_params.x} {parent.compression_params.y} {parent.compression_params.z}}
  DRT_ZCAM_v10_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_ZCAM_v10_Kernel_boundarySolvePrecision {{parent.solve_precision}}
  DRT_ZCAM_v10_Kernel_inverseSolverIterations {{parent.inverse_solver_iterations}}
  DRT_ZCAM_v10_Kernel_encodingOut {{parent.encoding_out}}
  DRT_ZCAM_v10_Kernel_primariesOut {{parent.primaries_out}}
  DRT_ZCAM_v10_Kernel_clampOutput {{parent.clamp_output}}
  DRT_ZCAM_v10_Kernel_invert {{parent.invert}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -231
 }
 Output {
  name Output1
  xpos -908
  ypos -154
 }
end_group
